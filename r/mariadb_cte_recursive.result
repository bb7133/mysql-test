create table t1 (a int, b varchar(32));
insert into t1 values
(4,'aaaa' ), (7,'bb'), (1,'ccc'), (4,'dd');
insert into t1 values
(3,'eee'), (7,'bb'), (1,'fff'), (4,'ggg');
with recursive
t as
(
select * from t1 where t1.b >= 'c'
union
select * from r
),
r as
(
select * from t
union
select t1.* from t1,r where r.a+1 = t1.a
)
select * from r;
Error 1146: Table 'mariadb_cte_recursive.r' doesn't exist
with recursive
a1(a,b) as
(select * from t1 where t1.a>3
union
select * from b1 where b1.a >3
union
select * from c1 where c1.a>3),
b1(a,b) as
(select * from a1 where a1.b > 'ccc'
union
select * from c1 where c1.b > 'ddd'),
c1(a,b) as
(select * from a1 where a1.a<6 and a1.b< 'zz'
union
select * from b1 where b1.b > 'auu')
select * from c1;
Error 1146: Table 'mariadb_cte_recursive.b1' doesn't exist
drop table t1;
# WITH RECURSIVE vs just WITH
create table t1 (a int);
insert into t1 values
(0), (1), (2), (3), (4);
create table t2 (a int);
insert into t2 values
(1), (2), (3), (4), (5);
# just WITH : s refers to t defined after s
with s(a) as (select t.a + 10 from t), t(a) as (select t1.a from t1) select * from s;
Error 1146: Table 'mariadb_cte_recursive.t' doesn't exist
# WITH RECURSIVE: s refers to t defined after s
with recursive s(a) as (select t.a + 10 from t), t(a) as (select t1.a from t1) select * from s;
Error 1146: Table 'mariadb_cte_recursive.t' doesn't exist
# just WITH : defined t1 is non-recursive and uses base tables t1,t2
with
t1 as
(
select a  from t2 where t2.a=3
union
select t2.a from t1,t2 where t1.a+1=t2.a
)
select * from t1 order by a;
a
1
2
3
4
5
explain
with
t1 as
(
select a  from t2 where t2.a=3
union
select t2.a from t1,t2 where t1.a+1=t2.a
)
select * from t1 order by a;
id	estRows	task	access object	operator info
Sort_34	8008.00	root		Column#8
└─CTEFullScan_37	8008.00	root	CTE:t1	data:CTE_0
CTE_0	8008.00	root		Non-Recursive CTE
└─HashAgg_19(Seed Part)	8008.00	root		group by:Column#7, funcs:firstrow(Column#7)->Column#7
  └─Union_20	12510.00	root		
    ├─TableReader_24	10.00	root		data:Selection_23
    │ └─Selection_23	10.00	cop[tikv]		eq(mariadb_cte_recursive.t2.a, 3)
    │   └─TableFullScan_22	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
    └─HashJoin_27	12500.00	root		inner join, equal:[eq(mariadb_cte_recursive.t2.a, Column#9)]
      ├─Projection_31(Build)	10000.00	root		plus(mariadb_cte_recursive.t1.a, 1)->Column#9
      │ └─TableReader_33	10000.00	root		data:TableFullScan_32
      │   └─TableFullScan_32	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
      └─TableReader_30(Probe)	10000.00	root		data:TableFullScan_29
        └─TableFullScan_29	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
#WITH RECURSIVE : defined t1 is recursive and uses only base table t2
with recursive
t1 as
(
select a  from t2 where t2.a=3
union
select t2.a from t1,t2 where t1.a+1=t2.a
)
select * from t1 order by a;
a
3
4
5
explain
with recursive
t1 as
(
select a  from t2 where t2.a=3
union
select t2.a from t1,t2 where t1.a+1=t2.a
)
select * from t1 order by a;
id	estRows	task	access object	operator info
Sort_31	20.50	root		mariadb_cte_recursive.t2.a
└─CTEFullScan_34	20.50	root	CTE:t1	data:CTE_0
CTE_0	20.50	root		Recursive CTE
├─TableReader_19(Seed Part)	10.00	root		data:Selection_18
│ └─Selection_18	10.00	cop[tikv]		eq(mariadb_cte_recursive.t2.a, 3)
│   └─TableFullScan_17	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─HashJoin_26(Recursive Part)	12.50	root		inner join, equal:[eq(Column#10, mariadb_cte_recursive.t2.a)]
  ├─Projection_27(Build)	10.00	root		plus(mariadb_cte_recursive.t2.a, 1)->Column#10
  │ └─CTETable_28	10.00	root		Scan on CTE_0
  └─TableReader_30(Probe)	10000.00	root		data:TableFullScan_29
    └─TableFullScan_29	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
# just WITH : types of t1 columns are determined by all parts of union
create view v1 as
with
t1 as
(
select a  from t2 where t2.a=3
union
select t2.a+1 from t1,t2 where t1.a=t2.a
)
select * from t1;
show columns from v1;
Field	Type	Null	Key	Default	Extra
a	bigint(20)	YES		NULL	
# WITH RECURSIVE : types of t1 columns are determined by anchor parts
create view v2 as
with recursive
t1 as
(
select a  from t2 where t2.a=3
union
select t2.a+1 from t1,t2 where t1.a=t2.a
)
select * from t1;
show columns from v2;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES		NULL	
drop view v1,v2;
drop table t1,t2;
create table  folks(id int, name char(32), dob date, father int, mother int);
insert into folks values
(100, 'Me', '2000-01-01', 20, 30),
(20, 'Dad', '1970-02-02', 10, 9),
(30, 'Mom', '1975-03-03', 8, 7),
(10, 'Grandpa Bill', '1940-04-05', null, null),
(9, 'Grandma Ann', '1941-10-15', null, null),
(25, 'Uncle Jim', '1968-11-18', 8, 7),
(98, 'Sister Amy', '2001-06-20', 20, 30),
(7, 'Grandma Sally', '1943-08-23', null, 6),
(8, 'Grandpa Ben', '1940-10-21', null, null),
(6, 'Grandgrandma Martha', '1923-05-17', null, null),
(67, 'Cousin Eddie', '1992-02-28', 25, 27),
(27, 'Auntie Melinda', '1971-03-29', null, null);
# simple recursion with one anchor and one recursive select
# the anchor is the first select in the specification
with recursive
ancestors
as
(
select *
from folks
where name = 'Me' and dob = '2000-01-01'
union
select p.id, p.name, p.dob, p.father, p.mother
from folks as p, ancestors AS a
where p.id = a.father or p.id = a.mother
)
select * from ancestors;
id	name	dob	father	mother
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
10	Grandpa Bill	1940-04-05	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
6	Grandgrandma Martha	1923-05-17	NULL	NULL
# simple recursion with one anchor and one recursive select
# the anchor is the last select in the specification
with recursive
ancestors
as
(
select *
from folks
where name = 'Me' and dob = '2000-01-01'
union
select p.*
from folks as p, ancestors AS a
where p.id = a.father or p.id = a.mother
)
select * from ancestors;
id	name	dob	father	mother
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
10	Grandpa Bill	1940-04-05	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
6	Grandgrandma Martha	1923-05-17	NULL	NULL
# simple recursion with one anchor and one recursive select
# the anchor is the first select in the specification
with recursive
ancestors
as
(
select *
from folks
where name = 'Cousin Eddie'
union
select p.*
from folks as p, ancestors as a
where p.id = a.father or p.id = a.mother
)
select * from ancestors;
id	name	dob	father	mother
67	Cousin Eddie	1992-02-28	25	27
25	Uncle Jim	1968-11-18	8	7
27	Auntie Melinda	1971-03-29	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
6	Grandgrandma Martha	1923-05-17	NULL	NULL
# simple recursion with or in anchor and or in recursive part
with recursive
ancestors
as
(
select *
from  folks
where name = 'Me' or name='Sister Amy'
union
select  p.*
from folks as p, ancestors as a
where p.id = a.father or p.id = a.mother
)
select * from ancestors;
id	name	dob	father	mother
100	Me	2000-01-01	20	30
98	Sister Amy	2001-06-20	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
10	Grandpa Bill	1940-04-05	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
6	Grandgrandma Martha	1923-05-17	NULL	NULL
# two recursive definition, one uses another
with recursive
prev_gen
as
(
select *
from folks
where name='Me'
union
select folks.*
from folks, prev_gen
where folks.id=prev_gen.father or folks.id=prev_gen.mother
),
ancestors
as
(
select *
from folks
where name='Me'
union
select *
from prev_gen
union
select *
from ancestors
)
select ancestors.name, ancestors.dob from ancestors order by ancestors.name, ancestors.dob;
name	dob
Dad	1970-02-02
Grandgrandma Martha	1923-05-17
Grandma Ann	1941-10-15
Grandma Sally	1943-08-23
Grandpa Ben	1940-10-21
Grandpa Bill	1940-04-05
Me	2000-01-01
Mom	1975-03-03
# simple recursion with one anchor and one recursive select
# the anchor is the first select in the specification
with recursive
descendants
as
(
select *
from folks
where name = 'Grandpa Bill'
union
select folks.*
from folks, descendants as d
where d.id=folks.father or d.id=folks.mother
)
select * from descendants;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
100	Me	2000-01-01	20	30
98	Sister Amy	2001-06-20	20	30
# simple recursion with one anchor and one recursive select
# the anchor is the first select in the specification
with recursive
descendants
as
(
select *
from folks
where name = 'Grandma Sally'
union
select folks.*
from folks, descendants as d
where d.id=folks.father or d.id=folks.mother
)
select * from descendants;
id	name	dob	father	mother
7	Grandma Sally	1943-08-23	NULL	6
30	Mom	1975-03-03	8	7
25	Uncle Jim	1968-11-18	8	7
100	Me	2000-01-01	20	30
98	Sister Amy	2001-06-20	20	30
67	Cousin Eddie	1992-02-28	25	27
# simple recursive table used three times in the main query
with recursive
ancestors
as
(
select *
from folks
where name = 'Me' and dob = '2000-01-01'
union
select p.*
from folks as p, ancestors AS a
where p.id = a.father OR p.id = a.mother
)
select *
from ancestors t1, ancestors t2
where exists (select * from ancestors a
where a.father=t1.id AND a.mother=t2.id);
id	name	dob	father	mother	id	name	dob	father	mother
20	Dad	1970-02-02	10	9	30	Mom	1975-03-03	8	7
10	Grandpa Bill	1940-04-05	NULL	NULL	9	Grandma Ann	1941-10-15	NULL	NULL
8	Grandpa Ben	1940-10-21	NULL	NULL	7	Grandma Sally	1943-08-23	NULL	6
# simple recursive table used three times in the main query
with
ancestor_couples(husband, h_dob, wife, w_dob)
as
(
with recursive
ancestors
as
(
select *
from folks
where name = 'Me'
union
select p.*
from folks as p, ancestors AS a
where p.id = a.father OR p.id = a.mother
)
select t1.name, t1.dob, t2.name, t2.dob
from ancestors t1, ancestors t2
where exists (select * from ancestors a
where a.father=t1.id AND a.mother=t2.id)
)
select * from ancestor_couples;
husband	h_dob	wife	w_dob
Dad	1970-02-02	Mom	1975-03-03
Grandpa Bill	1940-04-05	Grandma Ann	1941-10-15
Grandpa Ben	1940-10-21	Grandma Sally	1943-08-23
# simple recursion with two selects in recursive part
with recursive
ancestors
as
(
select *
from folks
where name = 'Me'
union
select p.*
from folks as p, ancestors as fa
where p.id = fa.father
union
select p.*
from folks as p, ancestors as ma
where p.id = ma.mother
)
select * from ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
# mutual recursion with renaming
with recursive
ancestor_couples(h_id, h_name, h_dob, h_father, h_mother,
w_id, w_name, w_dob, w_father, w_mother)
as
(
select h.*, w.*
from folks v, folks h, folks w
where v.name = 'Me' and
(v.father = h.id AND v.mother= w.id)
union
select h.*, w.*
from folks h, folks w,  coupled_ancestors a
where a.father = h.id AND a.mother = w.id
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select h_id, h_name, h_dob, h_father, h_mother
from ancestor_couples
union
select w_id, w_name, w_dob, w_father, w_mother
from ancestor_couples
)
select h_name, h_dob, w_name, w_dob
from ancestor_couples;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
with recursive
ancestor_couples(h_id, h_name, h_dob, h_father, h_mother,
w_id, w_name, w_dob, w_father, w_mother)
as
(
select h.*, w.*
from folks v, folks h, folks w
where v.name = 'Me' and
(v.father = h.id AND v.mother= w.id)
union
select h.*, w.*
from folks h, folks w,  coupled_ancestors a
where a.father = h.id AND a.mother = w.id
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select h_id, h_name, h_dob, h_father, h_mother
from ancestor_couples
union all
select w_id, w_name, w_dob, w_father, w_mother
from ancestor_couples
)
select h_name, h_dob, w_name, w_dob
from ancestor_couples;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
# mutual recursion with renaming
with recursive
ancestor_couples(h_id, h_name, h_dob, h_father, h_mother,
w_id, w_name, w_dob, w_father, w_mother)
as
(
select h.*, w.*
from folks v, folks h, folks w
where v.name = 'Me' and
(v.father = h.id AND v.mother= w.id)
union
select h.*, w.*
from folks h, folks w,  coupled_ancestors a
where a.father = h.id AND a.mother = w.id
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select h_id, h_name, h_dob, h_father, h_mother
from ancestor_couples
union
select w_id, w_name, w_dob, w_father, w_mother
from ancestor_couples
)
select h_name, h_dob, w_name, w_dob
from ancestor_couples;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
# mutual recursion with union all
with recursive
ancestor_couples(h_id, h_name, h_dob, h_father, h_mother,
w_id, w_name, w_dob, w_father, w_mother)
as
(
select h.*, w.*
from folks h, folks w,  coupled_ancestors a
where a.father = h.id AND a.mother = w.id
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select *
from folks
where name = 'Me'
union all
select h_id, h_name, h_dob, h_father, h_mother
from ancestor_couples
union all
select w_id, w_name, w_dob, w_father, w_mother
from ancestor_couples
)
select h_name, h_dob, w_name, w_dob
from ancestor_couples;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
# mutual recursion with one select in the first definition
with recursive
ancestor_couple_ids(h_id, w_id)
as
(
select a.father, a.mother
from coupled_ancestors a
where a.father is not null and a.mother is not null
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select *
from folks
where name = 'Me'
union all
select p.*
from folks p, ancestor_couple_ids fa
where p.id = fa.h_id
union all
select p.*
from folks p, ancestor_couple_ids ma
where p.id = ma.w_id
)
select *
from ancestor_couple_ids;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
with recursive
ancestor_couple_ids(h_id, w_id)
as
(
select a.father, a.mother
from coupled_ancestors a
where a.father is not null and a.mother is not null
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select *
from folks
where name = 'Me'
union all
select p.*
from folks p, ancestor_couple_ids fa
where p.id = fa.h_id
union all
select p.*
from folks p, ancestor_couple_ids ma
where p.id = ma.w_id
)
select h.name, h.dob, w.name, w.dob
from ancestor_couple_ids c, folks h, folks w
where c.h_id = h.id and c.w_id= w.id;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
# join of two mutually recursive tables
with recursive
ancestor_couple_ids(h_id, w_id)
as
(
select a.father, a.mother
from coupled_ancestors a
where a.father is not null and a.mother is not null
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select *
from folks
where name = 'Me'
union all
select p.*
from folks p, ancestor_couple_ids fa
where p.id = fa.h_id
union all
select p.*
from folks p, ancestor_couple_ids ma
where p.id = ma.w_id
)
select h.name, h.dob, w.name, w.dob
from ancestor_couple_ids c, coupled_ancestors h, coupled_ancestors w
where c.h_id = h.id and c.w_id= w.id;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
explain
with recursive
ancestor_couple_ids(h_id, w_id)
as
(
select a.father, a.mother
from coupled_ancestors a
where a.father is not null and a.mother is not null
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select *
from folks
where name = 'Me'
union all
select p.*
from folks p, ancestor_couple_ids fa
where p.id = fa.h_id
union all
select p.*
from folks p, ancestor_couple_ids ma
where p.id = ma.w_id
)
select h.name, h.dob, w.name, w.dob
from ancestor_couple_ids c, coupled_ancestors h, coupled_ancestors w
where c.h_id = h.id and c.w_id= w.id;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
# simple mutual recursion
with recursive
ancestor_couple_ids(h_id, w_id)
as
(
select a.father, a.mother
from coupled_ancestors a
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select *
from folks
where name = 'Me'
union all
select p.*
from folks p, ancestor_couple_ids fa
where p.id = fa.h_id
union all
select p.*
from folks p, ancestor_couple_ids ma
where p.id = ma.w_id
)
select *
from ancestor_couple_ids;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
# join of two mutually recursive tables
with recursive
ancestor_couple_ids(h_id, w_id)
as
(
select a.father, a.mother
from coupled_ancestors a
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select *
from folks
where name = 'Me'
union all
select p.*
from folks p, ancestor_couple_ids fa
where p.id = fa.h_id
union all
select p.*
from folks p, ancestor_couple_ids ma
where p.id = ma.w_id
)
select h.name, h.dob, w.name, w.dob
from ancestor_couple_ids c, coupled_ancestors h, coupled_ancestors w
where c.h_id = h.id and c.w_id= w.id;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
# execution of prepared query using a recursive table
prepare stmt1 from "with recursive ancestors as (   select *     from folks       where name = 'Me' and dob = '2000-01-01'   union    select p.id, p.name, p.dob, p.father, p.mother     from folks as p, ancestors AS a       where p.id = a.father or p.id = a.mother ) select * from ancestors; ";
execute stmt1;
id	name	dob	father	mother
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
10	Grandpa Bill	1940-04-05	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
6	Grandgrandma Martha	1923-05-17	NULL	NULL
execute stmt1;
id	name	dob	father	mother
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
10	Grandpa Bill	1940-04-05	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
6	Grandgrandma Martha	1923-05-17	NULL	NULL
deallocate prepare stmt1;
# view using a recursive table
create view v1 as
with recursive
ancestors
as
(
select *
from folks
where name = 'Me' and dob = '2000-01-01'
union
select p.id, p.name, p.dob, p.father, p.mother
from folks as p, ancestors AS a
where p.id = a.father or p.id = a.mother
)
select * from ancestors;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`%` SQL SECURITY DEFINER VIEW `v1` (`id`, `name`, `dob`, `father`, `mother`) AS WITH RECURSIVE `ancestors` AS (SELECT `mariadb_cte_recursive`.`folks`.`id` AS `id`,`mariadb_cte_recursive`.`folks`.`name` AS `name`,`mariadb_cte_recursive`.`folks`.`dob` AS `dob`,`mariadb_cte_recursive`.`folks`.`father` AS `father`,`mariadb_cte_recursive`.`folks`.`mother` AS `mother` FROM `mariadb_cte_recursive`.`folks` WHERE `name`=_UTF8MB4'Me' AND `dob`=_UTF8MB4'2000-01-01' UNION SELECT `p`.`id` AS `id`,`p`.`name` AS `name`,`p`.`dob` AS `dob`,`p`.`father` AS `father`,`p`.`mother` AS `mother` FROM (`mariadb_cte_recursive`.`folks` AS `p`) JOIN `ancestors` AS `a` WHERE `p`.`id`=`a`.`father` OR `p`.`id`=`a`.`mother`) SELECT `mariadb_cte_recursive`.`a`.`id` AS `id`,`mariadb_cte_recursive`.`a`.`name` AS `name`,`mariadb_cte_recursive`.`a`.`dob` AS `dob`,`mariadb_cte_recursive`.`a`.`father` AS `father`,`mariadb_cte_recursive`.`a`.`mother` AS `mother` FROM `ancestors`	utf8mb4	utf8mb4_general_ci
select * from v1;
id	name	dob	father	mother
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
10	Grandpa Bill	1940-04-05	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
6	Grandgrandma Martha	1923-05-17	NULL	NULL
create view v2 as
with recursive
ancestors
as
(
select *
from folks
where name = 'Me'
union
select p.*
from folks as p, ancestors as fa
where p.id = fa.father
union
select p.*
from folks as p, ancestors as ma
where p.id = ma.mother
)
select * from ancestors;
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`%` SQL SECURITY DEFINER VIEW `v2` (`id`, `name`, `dob`, `father`, `mother`) AS WITH RECURSIVE `ancestors` AS (SELECT `mariadb_cte_recursive`.`folks`.`id` AS `id`,`mariadb_cte_recursive`.`folks`.`name` AS `name`,`mariadb_cte_recursive`.`folks`.`dob` AS `dob`,`mariadb_cte_recursive`.`folks`.`father` AS `father`,`mariadb_cte_recursive`.`folks`.`mother` AS `mother` FROM `mariadb_cte_recursive`.`folks` WHERE `name`=_UTF8MB4'Me' UNION SELECT `mariadb_cte_recursive`.`p`.`id` AS `id`,`mariadb_cte_recursive`.`p`.`name` AS `name`,`mariadb_cte_recursive`.`p`.`dob` AS `dob`,`mariadb_cte_recursive`.`p`.`father` AS `father`,`mariadb_cte_recursive`.`p`.`mother` AS `mother` FROM (`mariadb_cte_recursive`.`folks` AS `p`) JOIN `ancestors` AS `fa` WHERE `p`.`id`=`fa`.`father` UNION SELECT `mariadb_cte_recursive`.`p`.`id` AS `id`,`mariadb_cte_recursive`.`p`.`name` AS `name`,`mariadb_cte_recursive`.`p`.`dob` AS `dob`,`mariadb_cte_recursive`.`p`.`father` AS `father`,`mariadb_cte_recursive`.`p`.`mother` AS `mother` FROM (`mariadb_cte_recursive`.`folks` AS `p`) JOIN `ancestors` AS `ma` WHERE `p`.`id`=`ma`.`mother`) SELECT `mariadb_cte_recursive`.`ma`.`id` AS `id`,`mariadb_cte_recursive`.`ma`.`name` AS `name`,`mariadb_cte_recursive`.`ma`.`dob` AS `dob`,`mariadb_cte_recursive`.`ma`.`father` AS `father`,`mariadb_cte_recursive`.`ma`.`mother` AS `mother` FROM `ancestors`	utf8mb4	utf8mb4_general_ci
select * from v2;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
drop view v1,v2;
explain
with recursive
ancestors
as
(
select *
from folks
where name = 'Me' and dob = '2000-01-01'
union
select p.id, p.name, p.dob, p.father, p.mother
from folks as p, ancestors AS a
where p.id = a.father or p.id = a.mother
)
select * from ancestors;
id	estRows	task	access object	operator info
CTEFullScan_31	100.01	root	CTE:ancestors	data:CTE_0
CTE_0	100.01	root		Recursive CTE
├─TableReader_19(Seed Part)	0.01	root		data:Selection_18
│ └─Selection_18	0.01	cop[tikv]		eq(mariadb_cte_recursive.folks.dob, 2000-01-01 00:00:00.000000), eq(mariadb_cte_recursive.folks.name, "Me")
│   └─TableFullScan_17	10000.00	cop[tikv]	table:folks	keep order:false, stats:pseudo
└─HashJoin_25(Recursive Part)	100.00	root		CARTESIAN inner join, other cond:or(eq(mariadb_cte_recursive.folks.id, mariadb_cte_recursive.folks.father), eq(mariadb_cte_recursive.folks.id, mariadb_cte_recursive.folks.mother))
  ├─CTETable_29(Build)	0.01	root		Scan on CTE_0
  └─TableReader_28(Probe)	10000.00	root		data:TableFullScan_27
    └─TableFullScan_27	10000.00	cop[tikv]	table:p	keep order:false, stats:pseudo
# recursive spec with two anchor selects and two recursive ones
with recursive
ancestor_ids (id)
as
(
select father from folks where name = 'Me'
union
select mother from folks where name = 'Me'
union
select father from folks, ancestor_ids a  where folks.id = a.id
union
select mother from folks, ancestor_ids a  where folks.id = a.id
),
ancestors
as
(
select p.* from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
# recursive spec using union all
with recursive
ancestors
as
(
select *
from folks
where name = 'Me'
union all
select p.*
from folks as p, ancestors as fa
where p.id = fa.father
union all
select p.*
from folks as p, ancestors as ma
where p.id = ma.mother
)
select * from ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
with recursive
ancestor_ids (id, generation)
as
(
select father, 1 from folks where name = 'Me' and  father is not null
union all
select mother, 1 from folks where name = 'Me' and  mother is not null
union all
select father, fa.generation+1 from folks, ancestor_ids fa
where folks.id = fa.id and (father not in (select id from ancestor_ids))
union all
select mother, ma.generation+1 from folks, ancestor_ids ma
where folks.id = ma.id and (mother not in (select id from ancestor_ids))
)
select generation, name from ancestor_ids a, folks
where a.id = folks.id;
Error 3577: In recursive query block of Recursive Common Table Expression 'ancestor_ids', the recursive table must be referenced only once, and not in any subquery
with recursive
ancestor_ids (id, generation)
as
(
select father from folks where name = 'Me' and  father is not null
union all
select mother from folks where name = 'Me' and  mother is not null
union all
select father, fa.generation+1 from folks, ancestor_ids fa
where folks.id = fa.id and (father not in (select id from ancestor_ids))
union all
select mother, ma.generation+1 from folks, ancestor_ids ma
where folks.id = ma.id and (mother not in (select id from ancestor_ids))
)
select generation, name from ancestor_ids a, folks
where a.id = folks.id;
Error 1353: In definition of view, derived table or common table expression, SELECT list and column names list have different column counts
with recursive
ancestor_ids (id, generation)
as
(
select father, 1 from folks where name = 'Me' and  father is not null
union all
select mother, 1 from folks where name = 'Me' and  mother is not null
union all
select father, fa.generation+1 from folks, ancestor_ids fa
where folks.id = fa.id and father is not null and
(father not in (select id from ancestor_ids))
union all
select mother, ma.generation+1 from folks, ancestor_ids ma
where folks.id = ma.id and mother is not null and
(mother not in (select id from ancestor_ids))
)
select generation, name from ancestor_ids a, folks
where a.id = folks.id;
Error 3577: In recursive query block of Recursive Common Table Expression 'ancestor_ids', the recursive table must be referenced only once, and not in any subquery
with recursive
coupled_ancestor_ids (id)
as
(
select father from folks where name = 'Me' and father is not null
union
select mother from folks where name = 'Me' and mother is not null
union
select n.father
from folks, coupled_ancestor_ids fa, coupled_ancestor_ids ma, folks n
where folks.father = fa.id and folks.mother = ma.id and
(fa.id = n.id or ma.id = n.id) and
n.father is not null and n.mother is not null
union
select n.mother
from folks, coupled_ancestor_ids fa, coupled_ancestor_ids ma, folks n
where folks.father = fa.id and folks.mother = ma.id and
(fa.id = n.id or ma.id = n.id) and
n.father is not null and n.mother is not null
)
select p.* from coupled_ancestor_ids a, folks p
where a.id = p.id;
Error 3577: In recursive query block of Recursive Common Table Expression 'coupled_ancestor_ids', the recursive table must be referenced only once, and not in any subquery
with recursive
coupled_ancestor_ids (id)
as
(
select father from folks where name = 'Me' and father is not null
union
select mother from folks where name = 'Me' and mother is not null
union
select n.father
from folks, coupled_ancestor_ids fa, coupled_ancestor_ids ma, folks n
where folks.father = fa.id and folks.mother = ma.id and
(fa.id = n.id or ma.id = n.id) and
n.father is not null and n.mother is not null
union
select n.mother
from folks, coupled_ancestor_ids fa, coupled_ancestor_ids ma, folks n
where folks.father = fa.id and folks.mother = ma.id and
(fa.id = n.id or ma.id = n.id) and
n.father is not null and n.mother is not null
)
select p.* from coupled_ancestor_ids a, folks p
where a.id = p.id;
Error 3577: In recursive query block of Recursive Common Table Expression 'coupled_ancestor_ids', the recursive table must be referenced only once, and not in any subquery
with recursive
ancestor_ids (id)
as
(
select father from folks where name = 'Me'
union
select mother from folks where name = 'Me'
union
select father from folks left join ancestor_ids a on folks.id = a.id
union
select mother from folks left join ancestor_ids a on folks.id = a.id
),
ancestors
as
(
select p.* from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
Error 3576: In recursive query block of Recursive Common Table Expression 'ancestor_ids', the recursive table must neither be in the right argument of a LEFT JOIN, nor be forced to be non-first with join order hints
with recursive
ancestor_ids (id)
as
(
select father from folks where name = 'Me'
union
select mother from folks where name = 'Me'
union
select father from folks left join ancestor_ids a on folks.id = a.id
union
select mother from folks left join ancestor_ids a on folks.id = a.id
),
ancestors
as
(
select p.* from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
Error 3576: In recursive query block of Recursive Common Table Expression 'ancestor_ids', the recursive table must neither be in the right argument of a LEFT JOIN, nor be forced to be non-first with join order hints
with recursive
ancestor_ids (id, generation)
as
(
select father, 1 from folks where name = 'Me'
union
select mother, 1 from folks where name = 'Me'
union
select father, a.generation+1 from folks, ancestor_ids a
where folks.id = a.id
union
select mother, a.generation+1 from folks, ancestor_ids a
where folks.id = a.id
),
ancestors
as
(
select generation, name from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
generation	name
1	Dad
1	Mom
2	Grandma Ann
2	Grandma Sally
2	Grandpa Ben
2	Grandpa Bill
3	Grandgrandma Martha
with recursive
ancestor_ids (id, generation)
as
(
select father, 1 from folks where name = 'Me'
union
select mother, 1 from folks where name = 'Me'
union
select max(father), max(a.generation)+1 from folks, ancestor_ids a
where folks.id = a.id
group by a.generation
union
select max(mother), max(a.generation)+1 from folks, ancestor_ids a
where folks.id = a.id
group by a.generation
),
ancestors
as
(
select generation, name from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
Error 3575: Recursive Common Table Expression 'ancestor_ids' can contain neither aggregation nor window functions in recursive query block
with recursive
ancestor_ids (id, generation)
as
(
select father, 1 from folks where name = 'Me'
union
select mother, 1 from folks where name = 'Me'
union
select max(father), a.generation+1 from folks, ancestor_ids a
where folks.id = a.id
group by a.generation
union
select max(mother), a.generation+1 from folks, ancestor_ids a
where folks.id = a.id
group by a.generation
),
ancestors
as
(
select generation, name from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
Error 3575: Recursive Common Table Expression 'ancestor_ids' can contain neither aggregation nor window functions in recursive query block
set cte_max_recursion_depth=1;
with recursive
ancestor_ids (id, generation)
as
(
select father, 1 from folks where name = 'Me'
union
select mother, 1 from folks where name = 'Me'
union
select father, a.generation+1 from folks, ancestor_ids a
where folks.id = a.id
union
select mother, a.generation+1 from folks, ancestor_ids a
where folks.id = a.id
),
ancestors
as
(
select generation, name from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
Error 3636: Recursive query aborted after 2 iterations. Try increasing @@cte_max_recursion_depth to a larger value
set cte_max_recursion_depth=1000;
# query with recursive tables using key access
alter table folks add primary key (id);
explain
with recursive
ancestors
as
(
select *
from folks
where name = 'Me'
union
select p.*
from folks as p, ancestors as fa
where p.id = fa.father
union
select p.*
from folks as p, ancestors as ma
where p.id = ma.mother
)
select * from ancestors;
id	estRows	task	access object	operator info
CTEFullScan_79	28.00	root	CTE:ancestors	data:CTE_0
CTE_0	28.00	root		Recursive CTE
├─TableReader_28(Seed Part)	10.00	root		data:Selection_27
│ └─Selection_27	10.00	cop[tikv]		eq(mariadb_cte_recursive.folks.name, "Me")
│   └─TableFullScan_26	10000.00	cop[tikv]	table:folks	keep order:false, stats:pseudo
└─HashAgg_36(Recursive Part)	20.00	root		group by:Column#41, Column#42, Column#43, Column#44, Column#45, funcs:firstrow(Column#41)->mariadb_cte_recursive.folks.id, funcs:firstrow(Column#42)->mariadb_cte_recursive.folks.name, funcs:firstrow(Column#43)->mariadb_cte_recursive.folks.dob, funcs:firstrow(Column#44)->mariadb_cte_recursive.folks.father, funcs:firstrow(Column#45)->mariadb_cte_recursive.folks.mother
  └─Union_37	20.00	root		
    ├─IndexJoin_43	10.00	root		inner join, inner:IndexLookUp_42, outer key:mariadb_cte_recursive.folks.father, inner key:mariadb_cte_recursive.folks.id, equal cond:eq(mariadb_cte_recursive.folks.father, mariadb_cte_recursive.folks.id)
    │ ├─Selection_54(Build)	8.00	root		not(isnull(mariadb_cte_recursive.folks.father))
    │ │ └─CTETable_55	10.00	root		Scan on CTE_0
    │ └─IndexLookUp_42(Probe)	1.00	root		
    │   ├─IndexRangeScan_40(Build)	1.00	cop[tikv]	table:p, index:PRIMARY(id)	range: decided by [eq(mariadb_cte_recursive.folks.id, mariadb_cte_recursive.folks.father)], keep order:false, stats:pseudo
    │   └─TableRowIDScan_41(Probe)	1.00	cop[tikv]	table:p	keep order:false, stats:pseudo
    └─IndexJoin_63	10.00	root		inner join, inner:IndexLookUp_62, outer key:mariadb_cte_recursive.folks.mother, inner key:mariadb_cte_recursive.folks.id, equal cond:eq(mariadb_cte_recursive.folks.mother, mariadb_cte_recursive.folks.id)
      ├─Selection_74(Build)	8.00	root		not(isnull(mariadb_cte_recursive.folks.mother))
      │ └─CTETable_75	10.00	root		Scan on CTE_0
      └─IndexLookUp_62(Probe)	1.00	root		
        ├─IndexRangeScan_60(Build)	1.00	cop[tikv]	table:p, index:PRIMARY(id)	range: decided by [eq(mariadb_cte_recursive.folks.id, mariadb_cte_recursive.folks.mother)], keep order:false, stats:pseudo
        └─TableRowIDScan_61(Probe)	1.00	cop[tikv]	table:p	keep order:false, stats:pseudo
with recursive
ancestors
as
(
select *
from folks
where name = 'Me'
union
select p.*
from folks as p, ancestors as fa
where p.id = fa.father
union
select p.*
from folks as p, ancestors as ma
where p.id = ma.mother
)
select * from ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
100	Me	2000-01-01	20	30
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
#
# EXPLAIN FORMAT=JSON on a query where one recursive CTE uses another:
#
explain
with recursive
prev_gen
as
(
select *
from folks
where name='Me'
union
select folks.*
from folks, prev_gen
where folks.id=prev_gen.father or folks.id=prev_gen.mother
),
ancestors
as
(
select *
from folks
where name='Me'
union
select *
from ancestors
union
select *
from prev_gen
)
select ancestors.name, ancestors.dob from ancestors;
Error 3574: Recursive Common Table Expression 'ancestors' should have one or more non-recursive query blocks followed by one or more recursive ones
explain
with recursive
prev_gen
as
(
select *
from folks
where name='Me'
union
select folks.*
from folks, prev_gen
where folks.id=prev_gen.father or folks.id=prev_gen.mother
),
ancestors
as
(
select *
from folks
where name='Me2'
union
select *
from ancestors where id < 234
union
select *
from prev_gen where id < 345
)
select ancestors.name, ancestors.dob from ancestors;
Error 3574: Recursive Common Table Expression 'ancestors' should have one or more non-recursive query blocks followed by one or more recursive ones
explain
with recursive
ancestor_couples(h_id, h_name, h_dob, h_father, h_mother,
w_id, w_name, w_dob, w_father, w_mother)
as
(
select h.*, w.*
from folks h, folks w,  coupled_ancestors a
where a.father = h.id AND a.mother = w.id
union
select h.*, w.*
from folks v, folks h, folks w
where v.name = 'Me' and
(v.father = h.id AND v.mother= w.id)
),
coupled_ancestors (id, name, dob, father, mother)
as
(
select h_id, h_name, h_dob, h_father, h_mother
from ancestor_couples
union all
select w_id, w_name, w_dob, w_father, w_mother
from ancestor_couples
)
select h_name, h_dob, w_name, w_dob
from ancestor_couples;
Error 1146: Table 'mariadb_cte_recursive.coupled_ancestors' doesn't exist
create table  my_ancestors(id int, name char(32), dob date, father int, mother int);
insert into my_ancestors
with recursive
ancestor_ids (id)
as
(
select father from folks where name = 'Me'
union
select mother from folks where name = 'Me'
union
select father from folks, ancestor_ids a  where folks.id = a.id
union
select mother from folks, ancestor_ids a  where folks.id = a.id
)
select p.* from folks as p, ancestor_ids as a where p.id = a.id;
select * from my_ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
delete from my_ancestors;
insert into my_ancestors
with recursive
ancestor_ids (id)
as
(
select father from folks where name = 'Me'
union
select mother from folks where name = 'Me'
union
select father from folks, ancestor_ids a  where folks.id = a.id
union
select mother from folks, ancestor_ids a  where folks.id = a.id
)
select p.* from folks as p, ancestor_ids as a where p.id = a.id;
select * from my_ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
drop table my_ancestors;
#
# MDEV-10883: execution of prepared statement from SELECT
#             with recursive CTE that renames columns
#
prepare stmt from " with recursive ancestor_ids (id) as (  select father from folks where name = 'Me'  union  select mother from folks where name = 'Me'  union  select father from folks, ancestor_ids a  where folks.id = a.id  union  select mother from folks, ancestor_ids a  where folks.id = a.id)select p.* from folks as p, ancestor_ids as a where p.id = a.id;";
execute stmt;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
deallocate prepare stmt;
#
# MDEV-10881: execution of prepared statement from
#             CREATE ... SELECT, INSERT ... SELECT
#
create table  my_ancestors(id int, name char(32), dob date, father int, mother int);
prepare stmt from"insert into my_ancestors with recursive ancestor_ids (id) as (   select father from folks where name = 'Me'   union   select mother from folks where name = 'Me'   union   select father from folks, ancestor_ids a  where folks.id = a.id   union   select mother from folks, ancestor_ids a  where folks.id = a.id ) select p.* from folks as p, ancestor_ids as a where p.id = a.id; ";
execute stmt;

deallocate prepare stmt;
select * from my_ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
delete from my_ancestors;
prepare stmt from" insert into my_ancestors with recursive ancestor_ids (id) as (   select father from folks where name = 'Me'   union   select mother from folks where name = 'Me'   union   select father from folks, ancestor_ids a  where folks.id = a.id   union   select mother from folks, ancestor_ids a  where folks.id = a.id ) select p.* from folks as p, ancestor_ids as a where p.id = a.id; ";
execute stmt;

deallocate prepare stmt;
select * from my_ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
drop table my_ancestors;
#
# MDEV-10933: WITH clause together with SELECT in parenthesis
#             CREATE SELECT
#
drop table folks;
#
# MDEV-10372: [bb-10.2-mdev9864 tree] EXPLAIN with recursive CTE enters endless recursion
#
create table t1(a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
explain
with recursive t as (select a from t1 union select a+10 from t where a < 1000)
select  * from t;
id	estRows	task	access object	operator info
CTEFullScan_18	8001.00	root	CTE:t	data:CTE_0
CTE_0	8001.00	root		Recursive CTE
├─TableReader_13(Seed Part)	10000.00	root		data:TableFullScan_12
│ └─TableFullScan_12	10000.00	cop[tikv]	table:t1	keep order:false, stats:pseudo
└─Projection_14(Recursive Part)	8000.00	root		cast(plus(mariadb_cte_recursive.t1.a, 10), int(11))->mariadb_cte_recursive.t1.a
  └─Selection_15	8000.00	root		lt(mariadb_cte_recursive.t1.a, 1000)
    └─CTETable_16	10000.00	root		Scan on CTE_0
drop table t1;
#
# MDEV-10737: recursive union with several anchors at the end
#
WITH RECURSIVE cte(n) AS
(SELECT 1 UNION SELECT 1 UNION SELECT n+1 FROM cte WHERE n < 5 )
SELECT * FROM cte;
n
1
2
3
4
5
#
# MDEV-10736: recursive definition with anchor over a table with blob
#
CREATE TABLE t1 (f VARCHAR(1024));
WITH RECURSIVE cte(f) AS
(SELECT t1.f FROM t1 UNION ALL SELECT cte.f FROM cte)
SELECT * FROM cte as t;
f
DROP TABLE t1;
#
# MDEV-10899: mergeable derived in the spec of recursive CTE
#
create table t1 (a int);
insert into t1 values
(0), (1), (2), (3), (4);
create table t2 (a int);
insert into t2 values
(1), (2), (3), (4), (5);
with recursive
t1 as
(
select x.a from (select a from t2 where t2.a=3) x
union
select t2.a from t1,t2 where t1.a+1=t2.a
)
select * from t1 order by a;
a
3
4
5
explain
with recursive
t1 as
(
select x.a from (select a from t2 where t2.a=3) x
union
select t2.a from t1,t2 where t1.a+1=t2.a
)
select * from t1 order by a;
id	estRows	task	access object	operator info
Sort_33	20.50	root		mariadb_cte_recursive.t2.a
└─CTEFullScan_36	20.50	root	CTE:t1	data:CTE_0
CTE_0	20.50	root		Recursive CTE
├─TableReader_21(Seed Part)	10.00	root		data:Selection_20
│ └─Selection_20	10.00	cop[tikv]		eq(mariadb_cte_recursive.t2.a, 3)
│   └─TableFullScan_19	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
└─HashJoin_28(Recursive Part)	12.50	root		inner join, equal:[eq(Column#10, mariadb_cte_recursive.t2.a)]
  ├─Projection_29(Build)	10.00	root		plus(mariadb_cte_recursive.t2.a, 1)->Column#10
  │ └─CTETable_30	10.00	root		Scan on CTE_0
  └─TableReader_32(Probe)	10000.00	root		data:TableFullScan_31
    └─TableFullScan_31	10000.00	cop[tikv]	table:t2	keep order:false, stats:pseudo
drop table t1,t2;
#
# MDEV-11278: non-mergeable view in the spec of recursive CTE
#
create table t1 (a int);
insert into t1 values
(0), (1), (2), (3), (4);
create table t2 (a int);
insert into t2 values
(1), (2), (3), (4), (5);
create view v1 as
select a from t2 where a < 3
union
select a from t2 where a > 4;
with recursive
t1 as
(
select a from v1 where a=1
union
select v1.a from t1,v1 where t1.a+1=v1.a
)
select * from t1;
a
1
2
drop view v1;
drop table t1,t2;
#
# MDEV-11259: recursive CTE with concatenation operation
#
DROP TABLE IF EXISTS edges;
CREATE TABLE edges(
a int(10) unsigned NOT NULL,
b int(10) unsigned NOT NULL,
PRIMARY KEY (a,b),
KEY b(b)
);
INSERT INTO edges
VALUES (1,3),(2,1),(2,4),(3,4),(3,5),(3,6),(4,7),(5,1),(5,6),(6,1);
DROP TABLE IF EXISTS edges2;
CREATE VIEW edges2 (a, b) AS
SELECT a, b FROM edges   UNION ALL   SELECT b, a FROM edges;
WITH RECURSIVE transitive_closure(a, b, distance, path_string) AS
( SELECT a, b, 1 AS distance,
concat(a, '.', b, '.') AS path_string
FROM edges
UNION ALL
SELECT tc.a, e.b, tc.distance + 1,
concat(tc.path_string, e.b, '.') AS path_string
FROM edges AS e
JOIN transitive_closure AS tc
ON e.a = tc.b
WHERE tc.path_string NOT LIKE concat('%', e.b, '.%')
)
SELECT * FROM transitive_closure
ORDER BY a, b, distance;
a	b	distance	path_string
1	3	1	1.3.
1	4	2	1.3.4.
1	5	2	1.3.5.
1	6	2	1.3.6.
1	6	3	1.3.5.6.
1	7	3	1.3.4.7.
2	1	1	2.1.
2	3	2	2.1.3.
2	4	1	2.4.
2	4	3	2.1.3.4.
2	5	3	2.1.3.5.
2	6	3	2.1.3.6.
2	6	4	2.1.3.5.6.
2	7	2	2.4.7.
2	7	4	2.1.3.4.7.
3	1	2	3.5.1.
3	1	2	3.6.1.
3	1	3	3.5.6.1.
3	4	1	3.4.
3	5	1	3.5.
3	6	1	3.6.
3	6	2	3.5.6.
3	7	2	3.4.7.
4	7	1	4.7.
5	1	1	5.1.
5	1	2	5.6.1.
5	3	2	5.1.3.
5	3	3	5.6.1.3.
5	4	3	5.1.3.4.
5	4	4	5.6.1.3.4.
5	6	1	5.6.
5	6	3	5.1.3.6.
5	7	4	5.1.3.4.7.
5	7	5	5.6.1.3.4.7.
6	1	1	6.1.
6	3	2	6.1.3.
6	4	3	6.1.3.4.
6	5	3	6.1.3.5.
6	7	4	6.1.3.4.7.
WITH RECURSIVE transitive_closure(a, b, distance, path_string) AS
( SELECT a, b, 1 AS distance,
concat(a, '.', b, '.') AS path_string
FROM edges
WHERE a = 1 -- source
UNION ALL
SELECT tc.a, e.b, tc.distance + 1,
concat(tc.path_string, e.b, '.') AS path_string
FROM edges AS e
JOIN transitive_closure AS tc ON e.a = tc.b
WHERE tc.path_string NOT LIKE concat('%', e.b, '.%')
)
SELECT * FROM transitive_closure
WHERE b = 6 -- destination
ORDER BY a, b, distance;
a	b	distance	path_string
1	6	2	1.3.6.
1	6	3	1.3.5.6.
WITH RECURSIVE transitive_closure(a, b, distance, path_string) AS
( SELECT  a, b, 1 AS distance,
concat(a, '.', b, '.') AS path_string
FROM edges2
UNION ALL
SELECT tc.a, e.b, tc.distance + 1,
concat(tc.path_string, e.b, '.') AS path_string
FROM edges2 AS e
JOIN transitive_closure AS tc ON e.a = tc.b
WHERE tc.path_string NOT LIKE concat('%', e.b, '.%')
)
SELECT * FROM transitive_closure
ORDER BY a, b, distance;
a	b	distance	path_string
1	2	1	1.2.
1	2	3	1.3.4.2.
1	2	4	1.5.3.4.2.
1	2	4	1.6.3.4.2.
1	2	5	1.5.6.3.4.2.
1	2	5	1.6.5.3.4.2.
1	3	1	1.3.
1	3	2	1.5.3.
1	3	2	1.6.3.
1	3	3	1.2.4.3.
1	3	3	1.5.6.3.
1	3	3	1.6.5.3.
1	4	2	1.2.4.
1	4	2	1.3.4.
1	4	3	1.5.3.4.
1	4	3	1.6.3.4.
1	4	4	1.5.6.3.4.
1	4	4	1.6.5.3.4.
1	5	1	1.5.
1	5	2	1.3.5.
1	5	2	1.6.5.
1	5	3	1.3.6.5.
1	5	3	1.6.3.5.
1	5	4	1.2.4.3.5.
1	5	5	1.2.4.3.6.5.
1	6	1	1.6.
1	6	2	1.3.6.
1	6	2	1.5.6.
1	6	3	1.3.5.6.
1	6	3	1.5.3.6.
1	6	4	1.2.4.3.6.
1	6	5	1.2.4.3.5.6.
1	7	3	1.2.4.7.
1	7	3	1.3.4.7.
1	7	4	1.5.3.4.7.
1	7	4	1.6.3.4.7.
1	7	5	1.5.6.3.4.7.
1	7	5	1.6.5.3.4.7.
2	1	1	2.1.
2	1	3	2.4.3.1.
2	1	4	2.4.3.5.1.
2	1	4	2.4.3.6.1.
2	1	5	2.4.3.5.6.1.
2	1	5	2.4.3.6.5.1.
2	3	2	2.1.3.
2	3	2	2.4.3.
2	3	3	2.1.5.3.
2	3	3	2.1.6.3.
2	3	4	2.1.5.6.3.
2	3	4	2.1.6.5.3.
2	4	1	2.4.
2	4	3	2.1.3.4.
2	4	4	2.1.5.3.4.
2	4	4	2.1.6.3.4.
2	4	5	2.1.5.6.3.4.
2	4	5	2.1.6.5.3.4.
2	5	2	2.1.5.
2	5	3	2.1.3.5.
2	5	3	2.1.6.5.
2	5	3	2.4.3.5.
2	5	4	2.1.3.6.5.
2	5	4	2.1.6.3.5.
2	5	4	2.4.3.1.5.
2	5	4	2.4.3.6.5.
2	5	5	2.4.3.1.6.5.
2	5	5	2.4.3.6.1.5.
2	6	2	2.1.6.
2	6	3	2.1.3.6.
2	6	3	2.1.5.6.
2	6	3	2.4.3.6.
2	6	4	2.1.3.5.6.
2	6	4	2.1.5.3.6.
2	6	4	2.4.3.1.6.
2	6	4	2.4.3.5.6.
2	6	5	2.4.3.1.5.6.
2	6	5	2.4.3.5.1.6.
2	7	2	2.4.7.
2	7	4	2.1.3.4.7.
2	7	5	2.1.5.3.4.7.
2	7	5	2.1.6.3.4.7.
2	7	6	2.1.5.6.3.4.7.
2	7	6	2.1.6.5.3.4.7.
3	1	1	3.1.
3	1	2	3.5.1.
3	1	2	3.6.1.
3	1	3	3.4.2.1.
3	1	3	3.5.6.1.
3	1	3	3.6.5.1.
3	2	2	3.1.2.
3	2	2	3.4.2.
3	2	3	3.5.1.2.
3	2	3	3.6.1.2.
3	2	4	3.5.6.1.2.
3	2	4	3.6.5.1.2.
3	4	1	3.4.
3	4	3	3.1.2.4.
3	4	4	3.5.1.2.4.
3	4	4	3.6.1.2.4.
3	4	5	3.5.6.1.2.4.
3	4	5	3.6.5.1.2.4.
3	5	1	3.5.
3	5	2	3.1.5.
3	5	2	3.6.5.
3	5	3	3.1.6.5.
3	5	3	3.6.1.5.
3	5	4	3.4.2.1.5.
3	5	5	3.4.2.1.6.5.
3	6	1	3.6.
3	6	2	3.1.6.
3	6	2	3.5.6.
3	6	3	3.1.5.6.
3	6	3	3.5.1.6.
3	6	4	3.4.2.1.6.
3	6	5	3.4.2.1.5.6.
3	7	2	3.4.7.
3	7	4	3.1.2.4.7.
3	7	5	3.5.1.2.4.7.
3	7	5	3.6.1.2.4.7.
3	7	6	3.5.6.1.2.4.7.
3	7	6	3.6.5.1.2.4.7.
4	1	2	4.2.1.
4	1	2	4.3.1.
4	1	3	4.3.5.1.
4	1	3	4.3.6.1.
4	1	4	4.3.5.6.1.
4	1	4	4.3.6.5.1.
4	2	1	4.2.
4	2	3	4.3.1.2.
4	2	4	4.3.5.1.2.
4	2	4	4.3.6.1.2.
4	2	5	4.3.5.6.1.2.
4	2	5	4.3.6.5.1.2.
4	3	1	4.3.
4	3	3	4.2.1.3.
4	3	4	4.2.1.5.3.
4	3	4	4.2.1.6.3.
4	3	5	4.2.1.5.6.3.
4	3	5	4.2.1.6.5.3.
4	5	2	4.3.5.
4	5	3	4.2.1.5.
4	5	3	4.3.1.5.
4	5	3	4.3.6.5.
4	5	4	4.2.1.3.5.
4	5	4	4.2.1.6.5.
4	5	4	4.3.1.6.5.
4	5	4	4.3.6.1.5.
4	5	5	4.2.1.3.6.5.
4	5	5	4.2.1.6.3.5.
4	6	2	4.3.6.
4	6	3	4.2.1.6.
4	6	3	4.3.1.6.
4	6	3	4.3.5.6.
4	6	4	4.2.1.3.6.
4	6	4	4.2.1.5.6.
4	6	4	4.3.1.5.6.
4	6	4	4.3.5.1.6.
4	6	5	4.2.1.3.5.6.
4	6	5	4.2.1.5.3.6.
4	7	1	4.7.
5	1	1	5.1.
5	1	2	5.3.1.
5	1	2	5.6.1.
5	1	3	5.3.6.1.
5	1	3	5.6.3.1.
5	1	4	5.3.4.2.1.
5	1	5	5.6.3.4.2.1.
5	2	2	5.1.2.
5	2	3	5.3.1.2.
5	2	3	5.3.4.2.
5	2	3	5.6.1.2.
5	2	4	5.1.3.4.2.
5	2	4	5.3.6.1.2.
5	2	4	5.6.3.1.2.
5	2	4	5.6.3.4.2.
5	2	5	5.1.6.3.4.2.
5	2	5	5.6.1.3.4.2.
5	3	1	5.3.
5	3	2	5.1.3.
5	3	2	5.6.3.
5	3	3	5.1.6.3.
5	3	3	5.6.1.3.
5	3	4	5.1.2.4.3.
5	3	5	5.6.1.2.4.3.
5	4	2	5.3.4.
5	4	3	5.1.2.4.
5	4	3	5.1.3.4.
5	4	3	5.6.3.4.
5	4	4	5.1.6.3.4.
5	4	4	5.3.1.2.4.
5	4	4	5.6.1.2.4.
5	4	4	5.6.1.3.4.
5	4	5	5.3.6.1.2.4.
5	4	5	5.6.3.1.2.4.
5	6	1	5.6.
5	6	2	5.1.6.
5	6	2	5.3.6.
5	6	3	5.1.3.6.
5	6	3	5.3.1.6.
5	6	5	5.1.2.4.3.6.
5	6	5	5.3.4.2.1.6.
5	7	3	5.3.4.7.
5	7	4	5.1.2.4.7.
5	7	4	5.1.3.4.7.
5	7	4	5.6.3.4.7.
5	7	5	5.1.6.3.4.7.
5	7	5	5.3.1.2.4.7.
5	7	5	5.6.1.2.4.7.
5	7	5	5.6.1.3.4.7.
5	7	6	5.3.6.1.2.4.7.
5	7	6	5.6.3.1.2.4.7.
6	1	1	6.1.
6	1	2	6.3.1.
6	1	2	6.5.1.
6	1	3	6.3.5.1.
6	1	3	6.5.3.1.
6	1	4	6.3.4.2.1.
6	1	5	6.5.3.4.2.1.
6	2	2	6.1.2.
6	2	3	6.3.1.2.
6	2	3	6.3.4.2.
6	2	3	6.5.1.2.
6	2	4	6.1.3.4.2.
6	2	4	6.3.5.1.2.
6	2	4	6.5.3.1.2.
6	2	4	6.5.3.4.2.
6	2	5	6.1.5.3.4.2.
6	2	5	6.5.1.3.4.2.
6	3	1	6.3.
6	3	2	6.1.3.
6	3	2	6.5.3.
6	3	3	6.1.5.3.
6	3	3	6.5.1.3.
6	3	4	6.1.2.4.3.
6	3	5	6.5.1.2.4.3.
6	4	2	6.3.4.
6	4	3	6.1.2.4.
6	4	3	6.1.3.4.
6	4	3	6.5.3.4.
6	4	4	6.1.5.3.4.
6	4	4	6.3.1.2.4.
6	4	4	6.5.1.2.4.
6	4	4	6.5.1.3.4.
6	4	5	6.3.5.1.2.4.
6	4	5	6.5.3.1.2.4.
6	5	1	6.5.
6	5	2	6.1.5.
6	5	2	6.3.5.
6	5	3	6.1.3.5.
6	5	3	6.3.1.5.
6	5	5	6.1.2.4.3.5.
6	5	5	6.3.4.2.1.5.
6	7	3	6.3.4.7.
6	7	4	6.1.2.4.7.
6	7	4	6.1.3.4.7.
6	7	4	6.5.3.4.7.
6	7	5	6.1.5.3.4.7.
6	7	5	6.3.1.2.4.7.
6	7	5	6.5.1.2.4.7.
6	7	5	6.5.1.3.4.7.
6	7	6	6.3.5.1.2.4.7.
6	7	6	6.5.3.1.2.4.7.
7	1	3	7.4.2.1.
7	1	3	7.4.3.1.
7	1	4	7.4.3.5.1.
7	1	4	7.4.3.6.1.
7	1	5	7.4.3.5.6.1.
7	1	5	7.4.3.6.5.1.
7	2	2	7.4.2.
7	2	4	7.4.3.1.2.
7	2	5	7.4.3.5.1.2.
7	2	5	7.4.3.6.1.2.
7	2	6	7.4.3.5.6.1.2.
7	2	6	7.4.3.6.5.1.2.
7	3	2	7.4.3.
7	3	4	7.4.2.1.3.
7	3	5	7.4.2.1.5.3.
7	3	5	7.4.2.1.6.3.
7	3	6	7.4.2.1.5.6.3.
7	3	6	7.4.2.1.6.5.3.
7	4	1	7.4.
7	5	3	7.4.3.5.
7	5	4	7.4.2.1.5.
7	5	4	7.4.3.1.5.
7	5	4	7.4.3.6.5.
7	5	5	7.4.2.1.3.5.
7	5	5	7.4.2.1.6.5.
7	5	5	7.4.3.1.6.5.
7	5	5	7.4.3.6.1.5.
7	5	6	7.4.2.1.3.6.5.
7	5	6	7.4.2.1.6.3.5.
7	6	3	7.4.3.6.
7	6	4	7.4.2.1.6.
7	6	4	7.4.3.1.6.
7	6	4	7.4.3.5.6.
7	6	5	7.4.2.1.3.6.
7	6	5	7.4.2.1.5.6.
7	6	5	7.4.3.1.5.6.
7	6	5	7.4.3.5.1.6.
7	6	6	7.4.2.1.3.5.6.
7	6	6	7.4.2.1.5.3.6.
WITH RECURSIVE transitive_closure(a, b, distance, path_string)
AS
( SELECT a, b, 1 AS distance,
concat(a, '.', b, '.') AS path_string
FROM edges2
UNION ALL
SELECT tc.a, e.b, tc.distance + 1,
concat(tc.path_string, e.b, '.') AS path_string
FROM edges2 AS e
JOIN transitive_closure AS tc ON e.a = tc.b
WHERE tc.path_string NOT LIKE concat('%', e.b, '.%')
)
SELECT a, b, min(distance) AS dist FROM transitive_closure
GROUP BY a, b
ORDER BY a, dist, b;
a	b	dist
1	2	1
1	3	1
1	4	2
1	5	1
1	6	1
1	7	3
2	1	1
2	3	2
2	4	1
2	5	2
2	6	2
2	7	2
3	1	1
3	2	2
3	4	1
3	5	1
3	6	1
3	7	2
4	1	2
4	2	1
4	3	1
4	5	2
4	6	2
4	7	1
5	1	1
5	2	2
5	3	1
5	4	2
5	6	1
5	7	3
6	1	1
6	2	2
6	3	1
6	4	2
6	5	1
6	7	3
7	1	3
7	2	2
7	3	2
7	4	1
7	5	3
7	6	3
DROP VIEW edges2;
DROP TABLE edges;
#
# MDEV-11674: recursive CTE table that cannot be stored
#             in a heap table
#
create table t1 (id int, test_data varchar(36));
insert into t1(id, test_data)
select id, test_data
from (
with recursive data_generator(id, test_data) as (
select 1 as id, uuid() as test_data
union all
select id + 1, uuid() from data_generator where id < 150000
)
select * from data_generator
) as a;
Error 3636: Recursive query aborted after 1001 iterations. Try increasing @@cte_max_recursion_depth to a larger value
drop table t1;
#
# MDEV-10773: ANALYZE for query with recursive CTE
#
explain
with recursive src(counter) as
(select 1
union
select counter+1 from src where counter<10
) select * from src;
id	estRows	task	access object	operator info
CTEFullScan_17	2.00	root	CTE:src	data:CTE_0
CTE_0	2.00	root		Recursive CTE
├─Projection_11(Seed Part)	1.00	root		1->Column#2
│ └─TableDual_12	1.00	root		rows:1
└─Projection_13(Recursive Part)	0.80	root		cast(plus(Column#3, 1), bigint(1) BINARY)->Column#5
  └─Selection_14	0.80	root		lt(Column#3, 10)
    └─CTETable_15	1.00	root		Scan on CTE_0
#
# mdev-12360: recursive reference in left operand of LEFT JOIN
#
drop table if exists folks;
create table  folks(id int, name char(32), dob date, father int, mother int);
insert into folks values
(100, 'Me', '2000-01-01', 20, 30),
(20, 'Dad', '1970-02-02', 10, 9),
(30, 'Mom', '1975-03-03', 8, 7),
(10, 'Grandpa Bill', '1940-04-05', null, null),
(9, 'Grandma Ann', '1941-10-15', null, null),
(25, 'Uncle Jim', '1968-11-18', 8, 7),
(98, 'Sister Amy', '2001-06-20', 20, 30),
(7, 'Grandma Sally', '1943-08-23', null, 6),
(8, 'Grandpa Ben', '1940-10-21', null, null),
(6, 'Grandgrandma Martha', '1923-05-17', null, null),
(67, 'Cousin Eddie', '1992-02-28', 25, 27),
(27, 'Auntie Melinda', '1971-03-29', null, null);
with recursive
ancestor_ids (id)
as
(
select father from folks where name = 'Me'
union
select mother from folks where name = 'Me'
union
select father from ancestor_ids as a left join folks on folks.id = a.id
union
select mother from ancestor_ids as a left join folks on folks.id = a.id
),
ancestors
as
(
select p.* from folks as p, ancestor_ids as a
where p.id = a.id
)
select * from ancestors;
id	name	dob	father	mother
10	Grandpa Bill	1940-04-05	NULL	NULL
20	Dad	1970-02-02	10	9
30	Mom	1975-03-03	8	7
6	Grandgrandma Martha	1923-05-17	NULL	NULL
7	Grandma Sally	1943-08-23	NULL	6
8	Grandpa Ben	1940-10-21	NULL	NULL
9	Grandma Ann	1941-10-15	NULL	NULL
drop table folks;
#
# mdev-12368: crash with mutually recursive CTE
#             that arenot Standard compliant
#
create table value_nodes (v char(4));
create table module_nodes(m char(4));
create table module_arguments(m char(4), v char(4));
create table module_results(m char(4), v char(4));
with recursive
reached_values as
(
select v from value_nodes where v in ('v3','v7','v9')
union
select module_results.v from module_results, applied_modules
where module_results.m = applied_modules.m
),
applied_modules as
(
select module_nodes.m
from
module_nodes
left join
(
module_arguments
left join
reached_values
on module_arguments.v = reached_values.v
)
on reached_values.v is null and
module_nodes.m = module_arguments.m
where module_arguments.m is null
)
select * from reached_values;
Error 1146: Table 'mariadb_cte_recursive.applied_modules' doesn't exist
drop table value_nodes, module_nodes, module_arguments, module_results;
#
# mdev-12375: query using one of two mutually recursive CTEs
#             whose non-recursive part returns an empty set
#
create table value_nodes (v char(4));
insert into value_nodes values
('v1'), ('v2'), ('v3'), ('v4'), ('v5'), ('v6'), ('v7'), ('v8'), ('v9'),
('v10'), ('v11'), ('v12'), ('v13'), ('v14'), ('v15'), ('v16');
create table module_nodes(m char(4));
insert into module_nodes values
('m1'), ('m2'), ('m3'), ('m4'), ('m5'), ('m6'), ('m7');
create table module_arguments(m char(4), v char(4));
insert into module_arguments values
('m1','v3'), ('m1','v9'),
('m2','v4'), ('m2','v3'), ('m2','v7'),
('m3','v6'),
('m4','v4'), ('m4','v1'),
('m5','v10'), ('m5','v8'), ('m5','v3'),
('m6','v8'), ('m6','v1'),
('m7','v11'), ('m7','v12');
create table module_results(m char(4), v char(4));
insert into module_results values
('m1','v4'),
('m2','v1'), ('m2','v6'),
('m3','v10'),
('m4','v8'),
('m5','v11'), ('m5','v9'),
('m6','v12'), ('m6','v4'),
('m7','v2');
with recursive
reached_values as
(
select v from value_nodes where v in ('v3','v7','v9')
union
select module_results.v from module_results, applied_modules
where module_results.m = applied_modules.m
),
applied_modules as
(
select * from module_nodes where 1=0
union
select module_nodes.m
from
module_nodes
left join
(
module_arguments
left join
reached_values
on module_arguments.v = reached_values.v
)
on reached_values.v is null and
module_nodes.m = module_arguments.m
where module_arguments.m is null
)
select * from applied_modules;
Error 1146: Table 'mariadb_cte_recursive.applied_modules' doesn't exist
drop table value_nodes, module_nodes, module_arguments, module_results;
#
# mdev-12519: recursive references in subqueries
#
create table t1 (lp char(4) not null, rp char(4) not null);
insert into t1 values
('p1','p2'), ('p2','p3'), ('p3','p4'), ('p4','p5'),
('p2','p7'), ('p7','p8'), ('p8','p3'), ('p8','p4');
with recursive
reachables(p) as
(
select lp from t1 where lp = 'p1'
union
select t1.rp from reachables, t1
where t1.lp = reachables.p
)
select * from reachables;
p
p1
p2
p3
p7
p4
p8
p5
with recursive
reachables(p) as
(
select lp from t1 where lp = 'p1'
union
select t1.rp from reachables, t1
where 'p3' not in (select * from reachables) and
t1.lp = reachables.p
)
select * from reachables;
Error 3577: In recursive query block of Recursive Common Table Expression 'reachables', the recursive table must be referenced only once, and not in any subquery
with recursive
reachables(p) as
(
select lp from t1 where lp = 'p1'
union
select t1.rp from reachables, t1
where 'p3' not in (select p from reachables where p <= 'p5'
union
select p from reachables where p > 'p5') and
t1.lp = reachables.p
)
select * from reachables;
Error 3577: In recursive query block of Recursive Common Table Expression 'reachables', the recursive table must be referenced only once, and not in any subquery
prepare stmt from "with recursive  reachables(p) as (    select lp from t1 where lp = 'p1'    union     select t1.rp from reachables, t1        where 'p3' not in (select p from reachables where p <= 'p5'                          union                          select p from reachables where p > 'p5') and                  t1.lp = reachables.p ) select * from reachables; ";
Error 3577: In recursive query block of Recursive Common Table Expression 'reachables', the recursive table must be referenced only once, and not in any subquery
drop table t1;
create table objects(v char(4) not null);
insert into objects values
('v1'), ('v2'), ('v3'), ('v4'), ('v5'),
('v6'), ('v7'), ('v8'), ('v9'), ('v10');
create table modules(m char(4) not null);
insert into modules values
('m1'), ('m2'), ('m3'), ('m4');
create table module_arguments(m char(4) not null, v char(4) not null);
insert into module_arguments values
('m1','v3'), ('m1','v9'),
('m2','v4'), ('m2','v7'),
('m3','v6'), ('m4','v2');
create table module_results(m char(4) not null, v char(4) not null);
insert into module_results values
('m1','v4'),
('m2','v1'), ('m2','v6'),
('m3','v10'), ('m4','v7');
with recursive
reached_objects as
(
select v, 'init' as m from objects where v in ('v3','v7','v9')
union
select module_results.v, module_results.m from module_results, applied_modules
where module_results.m = applied_modules.m
),
applied_modules as
(
select * from modules where 1=0
union
select modules.m
from
modules
where
not exists (select * from module_arguments
where module_arguments.m = modules.m and
module_arguments.v not in
(select v from reached_objects))
)
select * from reached_objects;
Error 1146: Table 'mariadb_cte_recursive.applied_modules' doesn't exist
with recursive
reached_objects as
(
select v, 'init' as m from objects where v in ('v3','v7','v9')
union
select module_results.v, module_results.m from module_results, applied_modules
where module_results.m = applied_modules.m
),
applied_modules as
(
select * from modules where 1=0
union
select modules.m
from
modules
where
'v6' not in (select v from reached_objects) and
not exists (select * from module_arguments
where module_arguments.m = modules.m and
module_arguments.v not in
(select v from reached_objects))
)
select * from reached_objects;
Error 1146: Table 'mariadb_cte_recursive.applied_modules' doesn't exist
prepare stmt from "with recursive reached_objects as  (   select v, 'init' as m from objects where v in ('v3','v7','v9')   union   select module_results.v, module_results.m from module_results, applied_modules      where module_results.m = applied_modules.m ), applied_modules as (   select * from modules where 1=0   union   select modules m   from     modules     where        'v6' not in (select v from reached_objects) and       not exists (select * from module_arguments                     where module_arguments.m = modules.m and                           module_arguments.v not in                            (select v from reached_objects)) ) select * from reached_objects; ";
Error 1146: Table 'mariadb_cte_recursive.applied_modules' doesn't exist
drop table objects, modules, module_arguments, module_results;
#
# mdev-12554: impossible where in recursive select
#
CREATE TABLE t1 (i int);
INSERT INTO t1 VALUES (1),(2);
WITH RECURSIVE
cte(f) AS ( SELECT i FROM t1 UNION SELECT f FROM t1, cte WHERE 1=0 )
SELECT * FROM cte;
f
1
2
DROP TABLE t1;
#
# mdev-12556: recursive execution uses Aria temporary tables
#
CREATE TABLE t (c1 varchar(255), c2 tinytext);
INSERT INTO t VALUES ('a','a'),('b','b'),('c','c'),('d','d');
DROP TABLE t;
#
# mdev-12563: no recursive references on the top level of the CTE spec
#
CREATE TABLE t (i int);
INSERT INTO t VALUES (3), (1),(2);
WITH RECURSIVE cte(f) AS (
SELECT i FROM t
UNION
SELECT i FROM t WHERE i NOT IN ( SELECT * FROM cte )
) SELECT * FROM cte;
Error 3577: In recursive query block of Recursive Common Table Expression 'cte', the recursive table must be referenced only once, and not in any subquery
WITH RECURSIVE cte(f) AS (
SELECT i FROM t
UNION
SELECT i FROM t WHERE i NOT IN ( SELECT * FROM cte WHERE i < 2 )
UNION
SELECT i FROM t WHERE i NOT IN ( SELECT * FROM cte WHERE i > 2 )
) SELECT * FROM cte;
Error 3577: In recursive query block of Recursive Common Table Expression 'cte', the recursive table must be referenced only once, and not in any subquery
WITH RECURSIVE cte(f) AS (
SELECT i FROM t
UNION
SELECT i FROM t
WHERE i NOT IN ( SELECT * FROM cte WHERE i < 2
UNION
SELECT * FROM cte WHERE i > 2)
) SELECT * FROM cte;
Error 3577: In recursive query block of Recursive Common Table Expression 'cte', the recursive table must be referenced only once, and not in any subquery
WITH RECURSIVE cte(f) AS (
SELECT i FROM t
UNION
SELECT i FROM t
WHERE i NOT IN ( SELECT * FROM t
WHERE i IN ( SELECT * FROM cte ) GROUP BY i )
) SELECT * FROM cte;
Error 3575: Recursive Common Table Expression 'cte' can contain neither aggregation nor window functions in recursive query block
WITH RECURSIVE cte(f) AS (
SELECT i FROM t
UNION
SELECT i FROM t WHERE i NOT IN ( SELECT * FROM cte )
UNION
SELECT * FROM cte WHERE f > 2
) SELECT * FROM cte;
Error 3577: In recursive query block of Recursive Common Table Expression 'cte', the recursive table must be referenced only once, and not in any subquery
DROP TABLE t;
#
# mdev-14184: recursive CTE embedded into CTE with multiple references
#
WITH
cte1 AS (
SELECT n FROM (
WITH RECURSIVE rec_cte(n) AS (
SELECT 1 as n1
UNION ALL
SELECT n+1 as n2 FROM rec_cte WHERE n < 3
) SELECT n FROM rec_cte
) AS X
),
cte2 as (
SELECT 2 FROM cte1
)
SELECT *
FROM cte1;
n
1
2
3
#
# mdev-14629: a user-defined variable is defined by the recursive CTE
#
set @var=
(
with recursive cte_tab(a) as (
select 1
union
select a+1 from cte_tab
where a<3)
select count(*) from cte_tab
);
select @var;
@var
3
create table t1(a int, b int);
insert into t1 values (3,8),(1,5),(5,7),(7,4),(4,3);
set @var=
(
with recursive summ(a,s) as (
select 1, 0 union
select t1.b, t1.b+summ.s from summ, t1
where summ.a=t1.a)
select s from summ
order by a desc
limit 1
);
select @var;
@var
27
set @var=
(
with recursive
cte_1 as (
select 1
union
select * from cte_2),
cte_2 as (
select * from cte_1
union
select a from t1, cte_2
where t1.a=cte_2.a)
select * from cte_2
limit 1
);
Error 1146: Table 'mariadb_cte_recursive.cte_2' doesn't exist
drop table t1;
#
# mdev-14777: crash caused by the same as in mdev-14755
#
#
# mdev-14879: subquery with recursive reference in WHERE of CTE
#
create table flights
(departure varchar(32),
arrival varchar(32),
carrier varchar(20),
flight_number char(7));
insert into flights values
('Seattle', 'Frankfurt', 'Lufthansa', 'LH 491'),
('Seattle', 'Chicago', 'American', 'AA 2573'),
('Seattle', 'Los Angeles', 'Alaska Air', 'AS 410'),
('Chicago', 'New York', 'American', 'AA 375'),
('Chicago', 'Montreal', 'Air Canada', 'AC 3053'),
('Los Angeles', 'New York', 'Delta', 'DL 1197'),
('Moscow', 'Tokyo', 'Aeroflot', 'SU 264'),
('New York', 'Paris', 'Air France', 'AF 23'),
('Frankfurt', 'Moscow', 'Lufthansa', 'LH 1444'),
('Tokyo', 'Seattle', 'ANA', 'NH 178'),
('Los Angeles', 'Tokyo', 'ANA', 'NH 175'),
('Moscow', 'Los Angeles', 'Aeroflot', 'SU 106'),
('Montreal', 'Paris', 'Air Canada', 'AC 870'),
('Cairo', 'Paris', 'Air France', 'AF 503'),
('New York', 'Seattle', 'American', 'AA 45'),
('Paris', 'Chicago', 'Air France', 'AF 6734');
with recursive destinations (city) as
( select a.arrival from flights a where a.departure='Cairo'
union
select b.arrival from destinations r, flights b where r.city=b.departure)
select * from destinations;
city
Paris
Chicago
New York
Montreal
Seattle
Frankfurt
Los Angeles
Moscow
Tokyo
drop table flights;
#
# MDEV-15162: Setting user variable in recursive CTE
#
SET @c=1;
WITH RECURSIVE cte AS
(SELECT 5
UNION
SELECT @c:=@c+1 FROM cte WHERE @c<3)
SELECT * FROM cte;
5
5
2
3
#
# MDEV-15575: using recursive cte with big_tables enabled
#
with recursive qn as
(select 123 as a union all select 1+a from qn where a<130)
select * from qn;
a
123
124
125
126
127
128
129
130
#
# MDEV-15571: using recursive cte with big_tables enabled
#
create table t1 (a bigint);
insert into t1 values(1);
with recursive qn as
(
select  a from t1
union all
select a*2000 from qn where a<10000000000000000000
)
select * from qn;
Error 1690: BIGINT value is out of range in '(mariadb_cte_recursive.t1.a * 2000)'
drop table t1;
#
# MDEV-15556: using recursive cte with big_tables enabled
#             when recursive tables are accessed by key
#
CREATE TABLE t1 (id int, name char(10), leftpar int, rightpar int);
INSERT INTO t1 VALUES
(1, "A", 2, 3), (2, "LA", 4, 5), (4, "LLA", 6, 7),
(6, "LLLA", NULL, NULL), (7, "RLLA", NULL, NULL), (5, "RLA", 8, 9),
(8, "LRLA", NULL, NULL), (9, "RRLA", NULL, NULL), (3, "RA", 10, 11),
(10, "LRA", 12, 13), (11, "RRA", 14, 15), (15, "RRRA", NULL, NULL),
(16, "B", 17, 18), (17, "LB", NULL, NULL), (18, "RB", NULL, NULL);
CREATE TABLE t2(id int, name char(10), leftpar int, rightpar int);
insert into t2 SELECT * FROM t1 ORDER BY rand();
DROP TABLE t1,t2;
#
# MDEV-15840: recursive tables are accessed by key
#             (the same problem as for MDEV-15556)
#
#
# MDEV-15894: aggregate/winfow functions in non-recorsive part
#
create table t1(b int);
insert into t1 values(10),(20),(10);
with recursive qn as
(select max(b) as a from t1 union
select a from qn)
select * from qn;
a
20
with recursive qn as
(select rank() over (order by b) as a from t1 union
select a from qn)
select * from qn;
a
1
3
drop table t1;
#
# MDEV-16086: tmp table for CTE is created as ARIA tables
#
CREATE TABLE t1 (
Id int(11) not null AUTO_INCREMENT,
Parent varchar(15) not null,
Child varchar(15) not null,
PRIMARY KEY (Id)
) ENGINE = MyISAM;
INSERT INTO t1 (Parent, Child) VALUES
('123', '456'),('456', '789'),('321', '654'),('654', '987');
WITH RECURSIVE cte AS
( SELECT b.Parent,
b.Child,
CAST(CONCAT(b.Child,',') AS CHAR(513)) Path
FROM t1 b
LEFT OUTER JOIN t1 bc ON b.Child = bc.Parent
WHERE bc.Id IS NULL
UNION ALL SELECT c.Parent,
c.Child,
CONCAT(p.Path,c.Child,',') Path
FROM t1 c
INNER JOIN cte p ON c.Child = p.Parent)
SELECT *
FROM cte
ORDER BY Path;
Parent	Child	Path
456	789	789,
123	456	789,456,
654	987	987,
321	654	987,654,
DROP TABLE t1;
#
# MDEV-16212: recursive CTE with global ORDER BY
#
set cte_max_recursion_depth = 2;
WITH RECURSIVE qn AS (
SELECT 1 FROM dual UNION ALL
SELECT 1 FROM qn
ORDER BY (SELECT * FROM qn))
SELECT count(*) FROM qn;
Error 1235: This version of TiDB doesn't yet support 'ORDER BY over UNION in recursive Common Table Expression'
set cte_max_recursion_depth = 1000;
#
# MDEV-15581: mix of ALL and DISTINCT UNION in recursive CTE
#
create table t1(a int);
insert into t1 values(1),(2);
insert into t1 values(1),(2);
set @c=0, @d=0;
WITH RECURSIVE qn AS
(
select 1,0 as col from t1
union distinct
select 1,0 from t1
union all
select 3, 0*(@c:=@c+1) from qn where @c<1
union all
select 3, 0*(@d:=@d+1) from qn where @d<1
)
select * from qn;
1	col
1	0
3	0
3	0
drop table t1;
#
# MDEV-16629: function with recursive CTE using a base table
#
CREATE TABLE t1 (id int);
INSERT INTO t1 VALUES (0), (1),(2);
WITH recursive cte AS
(SELECT id FROM t1 UNION SELECT 3 FROM cte)
SELECT count(id) FROM cte;
count(id)
4
DROP TABLE t1;
#
# MDEV-16661: function with recursive CTE using no base tables
#             (fixed by the patch for MDEV-16629)
#
#
# MDEV-17024: two materialized CTEs using the same recursive CTE
#
create table t1 (id int);
insert into t1 values (1), (2), (3);
create table t2 (c1 int, c2 int);
select * from t2;
c1	c2
drop table t2;
create table t2 (c1 int, c2 int);
drop table t1,t2;
#
# MDEV-17201: recursive part with LIMIT
#
CREATE TABLE purchases (
id int unsigned NOT NULL AUTO_INCREMENT,
pdate date NOT NULL,
quantity int unsigned NOT NULL,
p_id int unsigned NOT NULL,
PRIMARY KEY (id)
);
INSERT INTO purchases(pdate, quantity, p_id) VALUES
('2014-11-01',5 ,1),('2014-11-03', 3 ,1),
('2014-11-01',2 ,2),('2014-11-03', 4 ,2);
CREATE TABLE expired (
edate date NOT NULL,
quantity int unsigned NOT NULL,
p_id int unsigned NOT NULL,
PRIMARY KEY (edate,p_id)
);
INSERT INTO expired VALUES ('2014-11-12', 5 ,1),('2014-11-08', 1 ,2);
WITH RECURSIVE expired_map AS (
SELECT edate AS expired_date,
CAST(NULL AS date) AS purchase_date,
0 AS quantity,
e.p_id,
(SELECT MAX(id)+1 FROM purchases p
WHERE pdate <= edate AND p.p_id =p_id) AS purchase_processed,
quantity AS unresolved
FROM expired e
UNION
( SELECT expired_date,
pdate,
IF(p.quantity < m.unresolved, p.quantity, m.unresolved),
p.p_id,
p.id,
IF(p.quantity < m.unresolved, m.unresolved - p.quantity, 0)
FROM purchases p JOIN expired_map m ON p.p_id = m.p_id
WHERE p.id < m.purchase_processed AND m.unresolved > 0
ORDER BY p.id DESC
LIMIT 1
)
)
SELECT  * FROM expired_map;
Error 1235: This version of TiDB doesn't yet support 'ORDER BY / LIMIT / SELECT DISTINCT in recursive query block of Common Table Expression'
DROP TABLE purchases, expired;
#
# MDEV-17635: Two recursive CTEs, the second using the first
#
WITH RECURSIVE
x AS (SELECT 0 as k UNION ALL SELECT k + 1 FROM x WHERE k < 1),
z AS
( SELECT  k1 AS cx, k2 AS cy, k1, k2
FROM (SELECT k  AS k1 FROM x) x1 JOIN (SELECT k  AS k2 FROM x) y1
UNION
SELECT 1,1,1,1 FROM z)
SELECT * FROM z;
cx	cy	k1	k2
0	1	0	1
0	0	0	0
1	1	1	1
1	0	1	0
# https://wiki.postgresql.org/wiki/Mandelbrot_set:
WITH RECURSIVE x(i) AS (
SELECT CAST(0 AS DECIMAL(13, 10))
UNION ALL
SELECT i + 1
FROM x
WHERE i < 101
),
Z(Ix, Iy, Cx, Cy, X, Y, I) AS (
SELECT Ix, Iy, X, Y, X, Y, 0
FROM (SELECT CAST(-2.2 + 0.031 * i AS DECIMAL(13, 10)) AS X,
i AS Ix FROM x) AS xgen
CROSS JOIN (
SELECT CAST(-1.5 + 0.031 * i AS DECIMAL(13, 10)) AS Y,
i AS iY FROM x
) AS ygen
UNION ALL
SELECT Ix, Iy, Cx, Cy,
CAST(X * X - Y * Y + Cx AS DECIMAL(13, 10)) AS X,
CAST(Y * X * 2 + Cy AS DECIMAL(13, 10)), I + 1
FROM Z
WHERE X * X + Y * Y < 16.0
AND I < 27
),
Zt (Ix, Iy, I) AS (
SELECT Ix, Iy, MAX(I) AS I
FROM Z
GROUP BY Iy, Ix
ORDER BY Iy, Ix
)
SELECT GROUP_CONCAT(
SUBSTRING(
' .,,,-----++++%%%%@@@@#### ',
GREATEST(I, 1),
1
) ORDER BY Ix SEPARATOR ''
) AS 'Mandelbrot Set'
FROM Zt
GROUP BY Iy
ORDER BY Iy;
Mandelbrot Set
             ....................................................................................     
            .......................................................................................   
           .........................................................................................  
          ........................................................................................... 
        ....................................................,,,,,,,,,.................................
       ................................................,,,,,,,,,,,,,,,,,,.............................
      ..............................................,,,,,,,,,,,,,,,,,,,,,,,,..........................
     ............................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,........................
     ..........................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,......................
    .........................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....................
   ........................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...................
  .......................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.................
 .......................................,,,,,,,,,,,,,,,,,,,,,,,,--,,,,,,,,,,,,,,,,,,,,................
......................................,,,,,,,,,,,,,,,,,,,,,,,,,,-+--,,,,,,,,,,,,,,,,,,,...............
....................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----,,,,,,,,,,,,,,,,,,,..............
...................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,--- -----,,,,,,,,,,,,,,,,,.............
.................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---++--++,,,,,,,,,,,,,,,,,,............
................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----%++---,,,,,,,,,,,,,,,,,............
..............................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----+%----,,,,,,,,,,,,,,,,,,...........
.............................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,----- %%+----,,,,,,,,,,,,,,,,,,..........
...........................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---%-+%   ----,,,,,,,,,,,,,,,,,,,.........
..........................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---+ +##  %+%---,,,,,,,,,,,,,,,,,,.........
........................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----#      # +---,,,,,,,,,,,,,,,,,,........
.......................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-------%       %-----,,,,,,,,,,,,,,,,,........
.....................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---------+         ------,,,,,,,,,,,,,,,,,.......
....................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----------+@       +-----------,,,,,,,,,,,,.......
..................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,----@-------++       ++-----------,,,,,,,,,,,,......
.................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,--+@% ---+ +@%%@     %%+@+@%------+-,,,,,,,,,,,......
................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,----  # ++%               % @-----++--,,,,,,,,,,,.....
..............,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,----+    %                  %%++ %+%@-,,,,,,,,,,,.....
.............,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----+#                       #%    ++-,,,,,,,,,,,,....
............,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,------+                             @---,,,,,,,,,,,,....
..........,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-------++%                             ---,,,,,,,,,,,,....
.........,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,--------+ +                             %+---,,,,,,,,,,,,,...
........,,,,,,,,,,,,,,,,,,,,,--------------------@                                +----,,,,,,,,,,,,...
.......,,,,,,,,,,,,,,,,,,,,,,- +-----------------+                                 ----,,,,,,,,,,,,...
.......,,,,,,,,,,,,,,,,,,,,,--++------+---------+%                                 +++--,,,,,,,,,,,,..
......,,,,,,,,,,,,,,,,,,,,,,--%+-----++---------                                     #+-,,,,,,,,,,,,..
.....,,,,,,,,,,,,,,,,,,,,,,----#%++--+@ -+-----+%                                     --,,,,,,,,,,,,..
.....,,,,,,,,,,,,,,,,,,,,,,-----+## ++@ + +----%                                    +--,,,,,,,,,,,,,..
....,,,,,,,,,,,,,,,,,,,,,,------+@  @     @@++++#                                   +--,,,,,,,,,,,,,..
....,,,,,,,,,,,,,,,,,,,,,-------%           #++%                                      -,,,,,,,,,,,,,..
...,,,,,,,,,,,,,,,,,,,,,------++%#           %%@                                     %-,,,,,,,,,,,,,,.
...,,,,,,,,,,,,,,,,,,,--------+               %                                     +--,,,,,,,,,,,,,,.
...,,,,,,,,,,,,,,,,,,-----+--++@              #                                      --,,,,,,,,,,,,,,.
..,,,,,,,,,,,,,,,,,-------%+++%                                                    @--,,,,,,,,,,,,,,,.
..,,,,,,,,,,,-------------+ @#@                                                    ---,,,,,,,,,,,,,,,.
..,,,,,,,,,---@--------@-+%                                                       +---,,,,,,,,,,,,,,,.
..,,,,,------- +-++++-+%%%                                                       +----,,,,,,,,,,,,,,,.
..,,,,,,------%--------++%                                                       +----,,,,,,,,,,,,,,,.
..,,,,,,,,,,--+----------++#                                                       ---,,,,,,,,,,,,,,,.
..,,,,,,,,,,,,------------+@@@%                                                    +--,,,,,,,,,,,,,,,.
..,,,,,,,,,,,,,,,,,------- +++%                                                    %--,,,,,,,,,,,,,,,.
...,,,,,,,,,,,,,,,,,,---------+@              @                                      --,,,,,,,,,,,,,,.
...,,,,,,,,,,,,,,,,,,,,------- #              %@                                    +--,,,,,,,,,,,,,,.
...,,,,,,,,,,,,,,,,,,,,,-------++@           %+                                      %-,,,,,,,,,,,,,,.
....,,,,,,,,,,,,,,,,,,,,,-------            %++%                                     %-,,,,,,,,,,,,,..
....,,,,,,,,,,,,,,,,,,,,,,------+#  %#   #@ ++++                                    +--,,,,,,,,,,,,,..
.....,,,,,,,,,,,,,,,,,,,,,,-----+ %%++% +@+----+                                    +--,,,,,,,,,,,,,..
.....,,,,,,,,,,,,,,,,,,,,,,,---%+++--+#+--------%                                    #--,,,,,,,,,,,,..
......,,,,,,,,,,,,,,,,,,,,,,--++-----%%---------                                    @#--,,,,,,,,,,,,..
.......,,,,,,,,,,,,,,,,,,,,,---------------------+@                                +-++,,,,,,,,,,,,...
........,,,,,,,,,,,,,,,,,,,,,--------------------+                                 ----,,,,,,,,,,,,...
.........,,,,,,,,,,,,,,,,,,,,----,,,-------------                                #+----,,,,,,,,,,,,...
..........,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-------+ +                              +---,,,,,,,,,,,,,...
...........,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,--------+%#                           #---,,,,,,,,,,,,....
............,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,------+#                        @   @---,,,,,,,,,,,,....
.............,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----+#                        +    @--,,,,,,,,,,,,....
..............,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---+%   %+@                 %+-+ +++%-,,,,,,,,,,,.....
................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,----% %@++              # %  -----++-,,,,,,,,,,,,.....
.................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-- ++ ---+ + +%@     %++++++------%-,,,,,,,,,,,......
...................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---- -------++       +------------,,,,,,,,,,,,......
....................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----------+%       +--------,,,,,,,,,,,,,,,.......
......................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,--------+#        -----,,,,,,,,,,,,,,,,,,.......
.......................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-------+       #----,,,,,,,,,,,,,,,,,,........
.........................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,----+%      %#---,,,,,,,,,,,,,,,,,,,........
..........................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---+%+%@  %+%%--,,,,,,,,,,,,,,,,,,.........
............................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---+-+%  %----,,,,,,,,,,,,,,,,,,..........
.............................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----+%@+---,,,,,,,,,,,,,,,,,,,..........
...............................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----+%----,,,,,,,,,,,,,,,,,,...........
................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-----%+ +--,,,,,,,,,,,,,,,,,............
..................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,---++----,,,,,,,,,,,,,,,,,.............
...................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,---@-----,,,,,,,,,,,,,,,,,.............
.....................................,,,,,,,,,,,,,,,,,,,,,,,,,,,-----,,,,,,,,,,,,,,,,,,,..............
 .....................................,,,,,,,,,,,,,,,,,,,,,,,,,,--%,,,,,,,,,,,,,,,,,,,,...............
 .......................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.................
  ........................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,..................
   ........................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...................
    .........................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....................
     ..........................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,......................
      ............................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,........................
       .............................................,,,,,,,,,,,,,,,,,,,,,,,,..........................
        ................................................,,,,,,,,,,,,,,,,,.............................
         .....................................................,,,,....................................
          ........................................................................................... 
           .........................................................................................  
            ......................................................................................    
             ....................................................................................     
               .................................................................................      
                ..............................................................................        
                  ...........................................................................         
                   ........................................................................           
#
# MDEV-17871: EXPLAIN for query with not used recursive cte
#
create table t1 (a int);
insert into t1 values (2), (1), (4), (3);
create table t2 ( i1 int, i2 int);
insert into t2 values (1,1),(2,2);
drop table t1,t2;
#
# MDEV-22042: ANALYZE of query using stored function and recursive CTE
#
create table t1 (a1 varchar(20),a2 varchar(20)) engine=myisam;
insert into t1 values (1,1),(2,2),(3,3);
create table t2 (
a2 varchar(20) primary key, b1 varchar(20), key (b1)
) engine=myisam;
insert into t2 values (1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7);
insert into t2 values (11,11),(12,12),(13,13),(14,14),(15,15),(16,16),(17,17);
drop table t1,t2;
#
# MDEV-22748: two materialized CTEs using the same recursive CTE
# (see also test case for MDEV-17024)
#
CREATE TABLE t1 (YEAR int(4), d1 date , d2 date) ;
INSERT INTO t1 VALUES (2018,'2018-01-01','2018-09-20');
CREATE TABLE t2 (id int, tm date);
INSERT INTO t2 VALUES (1,'2018-08-30'),(2,'2018-08-30'),(3,'2018-08-30');
CREATE TABLE t3 (id int, tm date);
INSERT INTO t3 VALUES (1,'2018-08-30'),(2,'2018-08-30');
CREATE TABLE t4 (YEAR int(4), d1 date , d2 date);
DROP TABLE t1,t2,t3,t4;
#
# MDEV-23619: recursive CTE used only in the second operand of UNION
#
create table t1 (
a bigint(10) not null auto_increment,
b int(5) not null,
c bigint(10) default null,
primary key (a)
) engine myisam;
insert into t1 values
(1,3,12), (2,7,15), (3,1,3), (4,3,1);
#checking hanging cte that uses a recursive cte
drop table t1;
#
# MDEV-24019: query with recursive CTE when no default database is set
#
drop database if exists mdb_cte_recursive_test;
create database mdb_cte_recursive_tmp;
create table mdb_cte_recursive_tmp.t1 (a int);
insert into mdb_cte_recursive_tmp.t1 values (3), (7), (1);
drop database mdb_cte_recursive_tmp;
create database mdb_cte_recursive_test;
use mdb_cte_recursive_test;
#
# MDEV-23406: query with mutually recursive CTEs when big_tables=1
#
set @save_big_tables=@@big_tables;
set big_tables=1;
create table  folks(id int, name char(32), dob date, father int, mother int);
insert into folks values
(100, 'Me', '2000-01-01', 20, 30),
(20, 'Dad', '1970-02-02', 10, 9),
(30, 'Mom', '1975-03-03', 8, 7),
(10, 'Grandpa Bill', '1940-04-05', null, null),
(9, 'Grandma Ann', '1941-10-15', null, null),
(25, 'Uncle Jim', '1968-11-18', 8, 7),
(98, 'Sister Amy', '2001-06-20', 20, 30),
(7, 'Grandma Sally', '1943-08-23', null, 6),
(8, 'Grandpa Ben', '1940-10-21', null, null),
(6, 'Grandgrandma Martha', '1923-05-17', null, null),
(67, 'Cousin Eddie', '1992-02-28', 25, 27),
(27, 'Auntie Melinda', '1971-03-29', null, null);
drop table folks;
set big_tables=@save_big_tables;
#
# End of 10.2 tests
#
#
# MDEV-14217 [db crash] Recursive CTE when SELECT includes new field
#
CREATE TABLE a_tbl (
a VARCHAR(33) PRIMARY KEY,
b VARCHAR(33)
);
INSERT INTO a_tbl VALUES ('block0', 'block0'), ('block1', NULL);
WITH RECURSIVE Q0 AS (
SELECT T0.a, T0.b, 5
FROM a_tbl T0
WHERE b IS NULL
UNION ALL
SELECT T1.a, T1.b
FROM Q0
JOIN a_tbl T1
ON T1.a=Q0.a
) SELECT distinct(Q0.a), Q0.b
FROM Q0;
Error 1222: The used SELECT statements have a different number of columns
DROP TABLE a_tbl;
WITH RECURSIVE x AS (SELECT 1,2 UNION ALL SELECT 1 FROM x) SELECT * FROM x;
Error 1222: The used SELECT statements have a different number of columns
#
# MDEV-15162: Setting user variable in recursive CTE
#
SET @c=1;
WITH RECURSIVE cte AS
(SELECT 5
UNION
SELECT @c:=@c+1 FROM cte WHERE @c<3)
SELECT * FROM cte;
5
5
2
3
#
# MDEV-14883: recursive references in operands of INTERSECT / EXCEPT
#
create table flights
(departure varchar(32),
arrival varchar(32),
carrier varchar(20),
flight_number char(7));
insert into flights values
('Seattle', 'Frankfurt', 'Lufthansa', 'LH 491'),
('Seattle', 'Amsterdam', 'KLM', 'KL 6032'),
('Seattle', 'Chicago', 'American', 'AA 2573'),
('Seattle', 'Los Angeles', 'Alaska Air', 'AS 410'),
('Chicago', 'New York', 'American', 'AA 375'),
('Chicago', 'Montreal', 'Air Canada', 'AC 3053'),
('Los Angeles', 'New York', 'Delta', 'DL 1197'),
('New York', 'London', 'British Airways', 'BA 1511'),
('London', 'Moscow', 'British Airways', 'BA 233'),
('Moscow', 'Tokyo', 'Aeroflot', 'SU 264'),
('Moscow', 'Dubai', 'Emirates', 'EK 2421'),
('Dubai', 'Tokyo', 'Emirates', 'EK 318'),
('Dubai', 'Bangkok', 'Emirates', 'EK 2142'),
('Beijing', 'Bangkok', 'Air China', 'CA 757'),
('Beijing', 'Tokyo', 'Air China', 'CA 6653'),
('Moscow', 'Bangkok', 'Aeroflot', 'SU 270'),
('New York', 'Reykjavik', 'Icelandair', 'FL 416'),
('New York', 'Paris', 'Air France', 'AF 23'),
('Amsterdam', 'Moscow', 'KLM', 'KL 903'),
('Frankfurt', 'Dubai', 'Lufthansa', 'LH 630'),
('Frankfurt', 'Moscow', 'Lufthansa', 'LH 1444'),
('Reykjavik', 'London', 'British Airways', 'BA 2229'),
('Frankfurt', 'Beijing', 'Air China', 'CA 966'),
('Tokyo', 'Seattle', 'ANA', 'NH 178'),
('Los Angeles', 'Tokyo', 'ANA', 'NH 175'),
('Moscow', 'Los Angeles', 'Aeroflot', 'SU 106'),
('Montreal', 'Paris', 'Air Canada', 'AC 870'),
('London', 'Delhi', 'British Airways', 'BA 143'),
('Delhi', 'Bangkok', 'Air India', 'AI 306'),
('Delhi', 'Dubai', 'Air India', 'AI 995'),
('Dubai', 'Cairo', 'Emirates', 'EK 927'),
('Cairo', 'Paris', 'Air France', 'AF 503'),
('Amsterdam', 'New York', 'Delta', 'DL 47'),
('New York', 'Seattle', 'American', 'AA 45'),
('Paris', 'Chicago', 'Air France', 'AF 6734');
create table distances
(city1 varchar(32),
city2 varchar(32),
dist int);
insert into distances values
('Seattle', 'Frankfurt', 5080),
('Seattle', 'Amsterdam', 4859),
('Seattle', 'Chicago', 1733),
('Seattle', 'Los Angeles', 960),
('Chicago', 'New York', 712),
('Chicago', 'Montreal', 746),
('Los Angeles', 'New York', 2446),
('New York', 'London', 3459),
('London', 'Moscow', 1554),
('Moscow', 'Tokyo', 4647),
('Moscow', 'Dubai', 2298),
('Dubai', 'Tokyo', 4929),
('Dubai', 'Bangkok', 3050),
('Beijing', 'Bangkok', 2046),
('Beijing', 'Tokyo', 1301),
('Moscow', 'Bangkok', 4390),
('New York', 'Reykjavik', 2613),
('New York', 'Paris', 3625),
('Amsterdam', 'Moscow', 1334),
('Frankfurt', 'Dubai', 3003),
('Frankfurt', 'Moscow', 1256),
('Reykjavik', 'London', 1173),
('Frankfurt', 'Beijing', 4836),
('Tokyo', 'Seattle', 4783),
('Los Angeles', 'Tokyo', 5479),
('Moscow', 'Los Angeles', 6071),
('Moscow', 'Reykjavik', 2052),
('Montreal', 'Paris', 3425),
('London', 'Delhi', 4159),
('London', 'Paris', 214),
('Delhi', 'Bangkok', 1810),
('Delhi', 'Dubai', 1369),
('Delhi', 'Beijing', 2350),
('Dubai', 'Cairo', 1501),
('Cairo', 'Paris', 1992),
('Amsterdam', 'New York', 3643),
('New York', 'Seattle', 2402),
('Paris', 'Chicago', 4136),
('Paris', 'Los Angeles', 5647);
with recursive destinations (city) as
(
select a.arrival from flights a where a.departure = 'Seattle'
union
select b.arrival from destinations r, flights b where r.city = b.departure
)
select * from destinations;
city
Frankfurt
Amsterdam
Chicago
Los Angeles
New York
Montreal
Moscow
Dubai
Beijing
Tokyo
London
Bangkok
Reykjavik
Paris
Seattle
Cairo
Delhi
with recursive destinations (city) as
(
select a.arrival from flights a, distances d
where a.departure = 'Seattle' and
a.departure = d.city1 and a.arrival = d.city2 and
d.dist < 4000
union
select b.arrival from destinations r, flights b, distances d
where r.city = b.departure and
b.departure = d.city1 and b.arrival = d.city2 and
d.dist < 4000
)
select * from destinations;
city
Chicago
Los Angeles
New York
Montreal
London
Reykjavik
Paris
Seattle
Moscow
Dubai
Bangkok
Cairo
with recursive legs_to_destinations
(departure, arrival, dist, leg_no, acc_mileage) as
(
select a.departure, a.arrival, d.dist, 1, d.dist
from flights a, distances d
where a.departure = 'Seattle' and
a.departure = d.city1 and a.arrival = d.city2 and
d.dist < 4000
union all
select b.departure, b.arrival, d.dist, r.leg_no + 1, r.acc_mileage + d.dist
from legs_to_destinations r, flights b, distances d
where r.arrival = b.departure and
b.departure = d.city1 and b.arrival = d.city2 and
d.dist < 4000 and
b.arrival not in (select arrival from legs_to_destinations)
)
select * from legs_to_destinations;
Error 3577: In recursive query block of Recursive Common Table Expression 'legs_to_destinations', the recursive table must be referenced only once, and not in any subquery
with recursive destinations (city) as
(
select a.arrival from flights a, distances d
where a.departure = 'Seattle' and
a.departure = d.city1 and a.arrival = d.city2 and
d.dist < 4000
union
select b.arrival from destinations r, flights b
where r.city = b.departure
intersect
select city2 from destinations s, distances d
where s.city = d.city1 and d.dist < 4000
)
select * from destinations;
Error 1235: This version of TiDB doesn't yet support 'INTERSECT between recursive part's selects, hint: The operator between recursive part's selects must bu UNION[DISTINCT] or UNION ALL'
with recursive destinations (city) as
(
select a.arrival from flights a where a.departure = 'Seattle'
union
select * from
(
select b.arrival from destinations r, flights b
where r.city = b.departure
except
select arrival from flights
where arrival in
('New York', 'London', 'Moscow', 'Dubai', 'Cairo', 'Tokyo')
) t
)
select * from destinations;
Error 3577: In recursive query block of Recursive Common Table Expression 'destinations', the recursive table must be referenced only once, and not in any subquery
drop table flights, distances;
#
# MDEV-15159: Forced nullability of columns in recursive CTE
#
WITH RECURSIVE cte AS (
SELECT 1 AS a UNION ALL
SELECT NULL FROM cte WHERE a IS NOT NULL)
SELECT * FROM cte;
a
1
NULL
CREATE TABLE t1 (a int NOT NULL);
INSERT INTO t1 VALUES (0);
WITH RECURSIVE cte AS
(SELECT a FROM t1 where a=0 UNION SELECT NULL FROM cte)
SELECT * FROM cte;
a
0
NULL
DROP TABLE t1;
# End of 10.3 tests
